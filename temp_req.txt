ID,Requirement,Notes / Rationale,Gaps / TBDs,To include in T4,Relevant digital block-level IP,Digital block-level IP requirement,Verification strategy,,LongerTest Description
DIG-1,A power on reset signal shall reset the system to a known state at power on,,,Yes,TLM ,As in requirement,Functional verification,,"Apply power-on sequence with NRST asserted low. Monitor all internal registers, FSMs, and memory elements. Verify all reach documented reset values (e.g., sampling disabled, channels off, dividers at safe defaults). Check no unknown (X) or high-impedance (Z) states exist in any flip-flop."
DIG-2,Reset release shall be managed with any always on clock to prevent unknown states,,,Yes,TLM ,As in requirement,Functional verification,,"Assert NRST asynchronously, then release synchronously to the HF_CLK domain. Use assertions to verify reset synchronizers (2-FF chains) in each domain. Monitor all register outputs for metastability or X/Z states during and after release. Verify no combinational glitches propagate from reset tree. The SCK domain has an intermittent clock so reset will need to be asynchronous"
DIG-3,The digital design shall be optimised for low power (subject to the area constraints),,,,,,,,
DIG-4,"The digital subsystem shall implement a 4-wire SPI slave interface with signals SCLK, CS, MOSI, MISO.",Basic host interface.,,Yes,SPI,As in requirement,Functional verification,,"Drive randomized SPI transactions with varying CS, SCLK, and MOSI patterns. Monitor that MISO responds correctly. Verify all four signals are present and toggle during transactions. Use protocol checker to flag violations (e.g., MISO driving when CS high, SCLK glitches)."
DIG-5,"SPI shall support 16-bit words, MSB-first, with CS low for the entire transaction.",Matches current protocol description.,,Yes,SPI,As in requirement,Functional verification,,"Send constrained-random 16-bit words via SPI with known bit patterns (e.g., 0xA5C3, 0x0001, 0xFFFF). Verify MSB transmitted/received first by monitoring bit order on MOSI/MISO. Assert CS remains low for all 16 SCLK cycles. Check CS goes high only after final bit. Verify word boundaries align with CS edges."
DIG-6,"SPI shall operate in mode~0 (CPOL=0, CPHA=0). If necessary mode 3 is an acceptable fallback",From specification.,,Yes,SPI,As in requirement,Functional verification,,"Configure SPI master for mode 0 (CPOL=0, CPHA=0). Use assertions to verify SCLK idles low when CS high. Monitor that data is sampled on SCLK rising edge and shifted on falling edge. Send test patterns and verify correct data capture. If mode 3 used, verify CPOL=1, CPHA=1 behavior (idle high, sample on falling edge)."
DIG-7,The maximum supported SCLK frequency shall be specified and verified (spec currently targets up to approximately \SI{15}{MHz}).,Impacts timing closure and verification.15MHz was achieved on all Pepper T3 chips and should provide sufficient for all data communication tasks.,,Yes,TLM,As in requirement,Timing analysis,,"Run post-layout static timing analysis at 15MHz SCLK frequency. Verify all setup and hold times meet requirements with margin (e.g., >100ps). Perform gate-level simulation with back-annotated SDF delays at 15MHz. Execute full register read/write sequences and FIFO readout. Check for timing violations, metastability, or data corruption. Test across PVT corners."
DIG-8,A high-frequency clock input HF_CLK shall be provided for the conversion/sampling domain. The HF_CLK shall be less than 8.096Mhz and have a jitter less than 3ns,Drives sampling and internal clocks. 3ns jitter requirment comes from the ADC. 8.096Mhz is the max that the clock divider can support. Minimum clock frequency is likely to be application specific,,Yes,BURST DIVIDER,As in requirement,Functional verification,,"Apply HF_CLK at maximum frequency (8.096MHz) with jitter profile <3ns peak-to-peak. Use real-number modeling or mixed-signal testbench to inject jitter. Monitor derived clocks (conversion, sampling) for jitter amplification. Verify all clock dividers lock and produce stable outputs. Use assertions to measure period variation and flag violations >3ns."
DIG-9,A DATA_READY output shall indicate that at least one complete multi-channel sample frame is unread.,Used by host to signal data is ready for readout.,,Yes,ADC CONTROL,As in requirement,Functional verification,,"Enable subset of channels and initiate sampling. Monitor internal FIFO write pointer. When one complete frame (all enabled channels) is written, verify DATA_READY asserts within 1 SCLK cycle. Read frame via SPI and verify DATA_READY deasserts when FIFO falls below threshold. Use scoreboard to track frame count vs. DATA_READY state."
DIG-10,A NRST pin shall asynchronously reset all digital logic to a safe default state.,Global digital reset.,,Yes,TLM,As in requirement,Functional verification,,"Assert NRST asynchronously during active operation (mid-transaction, mid-conversion). Verify immediate reset of all logic regardless of clock state. Run CDC analysis tool (SpyGlass CDC, Questa CDC) to verify reset topology. Check all async reset paths are properly synchronized. Verify no reset glitches or race conditions. Confirm safe defaults are reached."
DIG-11,"Dedicated scan pins (SCAN_EN, SCAN_CLK, SCAN_IN, SCAN_OUT) shall support scan test.",For DFT.,,Yes,TLM,As in requirement,Functional verification,,"Insert scan chains using DFT tool. Assert SCAN_EN to enable scan mode. Shift known patterns into scan chains via SCAN_IN using SCAN_CLK. Capture functional state, then shift out via SCAN_OUT. Compare shifted-out data with expected values. Run ATPG-generated patterns and verify fault coverage >95%. Check scan chains don't affect functional mode (SCAN_EN=0)."
DIG-12,OTP control/test pins (e.g. OTP_TEST) shall support fuse programming and production test.,Digital must interface to the OTP macro.,"Depends on OTP chosen and whether OTP is included in T4. Exact OTP interface pin list, protocols and timing are TBD.",Not known,TLM,As in requirement,Functional verification,,"Assert OTP_TEST pin to enter OTP test mode. Verify digital logic tristates normal outputs and enables OTP access path. Apply OTP programming sequence (address, data, program pulse) per OTP spec. Read back programmed values and verify match. Check test mode exit returns to normal operation. Verify OTP interface timing meets macro requirements."
DIG-13,The digital subsystem shall support periodic clocked sampling.,From specification.,,Yes,TLM,As in requirement,Functional verification,,"Set clock dividers to known values. Enable one or more channels. Monitor SAMPLE_CLK and ADC conversion triggers. Verify conversions occur at regular, predictable intervals derived from HF_CLK. Use timestamp scoreboard to check period consistency (jitter within spec). Verify multi-channel frames are complete and sequential."
DIG-14,DELETED,,,,N/A,N/A,N/A,,N/A
DIG-15,DELETED,,,,N/A,N/A,N/A,,N/A
DIG-16,sampling shall be autonomous at a programmable rate derived from HF_CLK,Continuous/streaming mode.,,Yes,TLM,As in requirement,Functional verification,,"Program CLK_DIV_CONV and CLK_DIV_SAMP registers to set sampling rate. Enable autonomous mode in MODE_CTRL. Verify sampling continues without host intervention. Monitor DATA_READY pin - should assert when frame available. Host polls DATA_READY, reads FIFO when high. Verify continuous operation over extended period (100+ frames). Check no host interaction needed between reads."
DIG-17,DELETED,,,,N/A,N/A,N/A,,N/A
DIG-18,DATA_READY shall be high whilst the amount of data in the FIFO is above the watermark ,Defines basic semantics for host interface.,,Yes,ADC CONTROL,As in requirement,Functional verification,,Configure FIFO watermark threshold. Gradually fill FIFO by sampling without reading. Monitor internal FIFO count and DATA_READY pin. Verify DATA_READY asserts exactly when count crosses watermark threshold (cycle-accurate check). Keep filling - DATA_READY should remain high. Begin reading - verify DATA_READY stays high while above watermark. Use scoreboard to track FIFO occupancy vs. DATA_READY state at every clock cycle.
DIG-19,FIFO overflow must be flagged in the status register,From data-buffering description.,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Fill FIFO to maximum capacity by continuous sampling without host reads. Continue sampling to force overflow condition. Immediately read the status register via SPI. Verify overflow flag bit is set (=1). Test flag persistence (sticky vs. auto-clear). If sticky, write-1-to-clear and verify flag clears. Use UVM RAL model to predict and check register state. Verify overflow doesn't corrupt existing FIFO data."
DIG-20,DATA_READY shall be asserted when the FIFO WATERMARK is high. DATA_READY should be deasserted when the FIFO WATERMARK signal goes low,,,Yes,ADC CONTROL,As in requirement,Functional verification,,"Start with empty FIFO. Incrementally add frames while monitoring FIFO depth and DATA_READY. Verify DATA_READY asserts when depth reaches exactly 50% (e.g., 8 frames in 16-deep FIFO). Continue filling - DATA_READY stays high. Begin reading frames. Verify DATA_READY deasserts when depth drops below 50%. Test hysteresis if present. Use scoreboard to track high watermark (50% for assert) and low watermark (50% for deassert). Verify no glitches on DATA_READY during transitions."
DIG-21,FIFO underflow (i.e. read when empty) shall be flagged in the status register,,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Ensure FIFO is empty (reset or read all data). Issue SPI read-data command to attempt reading from empty FIFO. Verify read returns defined value (e.g., all zeros or last value). Immediately read status register. Verify underflow flag is set. Test multiple consecutive underflow reads - flag should remain set or increment counter. Clear flag and verify it clears. Ensure underflow doesn't cause system hang or corruption."
DIG-22,FIFO word width shall be number of channels * bits per channel. nominally 8 * 16.,,,Yes,FIFO,As in requirement,Functional verification,,"Configure all 8 channels enabled (CHAN_EN = 0xFF). Each channel produces 16-bit samples. Calculate expected FIFO word width: 8 Ã— 16 = 128 bits. Write one complete frame to FIFO. Use backdoor access or waveform inspection to verify FIFO memory width is 128 bits. Read frame via SPI - should require 8 SPI words (16 bits each). Test with different channel enable patterns (e.g., 4 channels = 64-bit words). Scoreboard tracks expected vs. actual word packing."
DIG-23,FIFO words shall default to all zero and only enabled channels will be populated with data,,,Yes,FIFO,As in requirement,Functional verification,,"Enable subset of channels (e.g., CHAN_EN = 0b10101010, channels 1,3,5,7). Inject known non-zero ADC data on enabled channels. Perform sampling and write to FIFO. Read FIFO word via SPI. Verify enabled channel positions contain ADC data. Verify disabled channel positions (0,2,4,6) read as 0x0000. Test with various enable patterns. Scoreboard predicts frame structure based on CHAN_EN and compares with readback. Verify no data leakage between channels."
DIG-24,FIFO words shall be set to zero when read,,,Yes,FIFO,As in requirement,Functional verification,,"Write known data pattern to FIFO (e.g., 0xA5A5 per channel). Read FIFO entry via SPI read-data command. Capture returned data and verify it matches written pattern. Immediately after SPI transaction completes, use backdoor memory access (hierarchical reference in testbench) to inspect FIFO RAM at the read address. Verify memory location now contains all zeros. Repeat for multiple FIFO locations. Ensures read-clear behavior and prevents data reuse."
DIG-25,The digital design shall change which channel is selected on the multiplexer on the rising edge of the sample clock,,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,Enable multiple channels for sequential sampling. Monitor SAMPLE_CLK and analog mux select signals (CHSEL or equivalent). Use assertions or waveform analysis to verify mux select changes occur coincident with SAMPLE_CLK rising edge (within same simulation delta). Verify no glitches or intermediate states on mux select. Test across different sampling rates and channel counts. Ensure setup time for analog mux is met before next SAMPLE_CLK edge.
DIG-26,The multplexer signal (ATMCHSEL[7:0]) is one hot encoded and should be 'break before make',,,Yes,ADC CONTROL,As in requirement,Functional verification,,"Monitor ATMCHSEL bus during channel sequencing. Use assertions to assert one-hot encoding: $onehot(ATMCHSEL) or ATMCHSEL==0. Verify 'break-before-make': when transitioning from channel N to N+1, at the input to the ATM multiplexer. Check no two bits are ever high simultaneously. Measure break duration. Test all channel transitions (0â†’1, 1â†’2, ..., 7â†’0). Prevents analog mux contention and signal corruption."
DIG-27,The FIFO readout shall be synchronous to the SPI clock domain,,,Yes ,COMMAND INTEPRETER ,As in requirement,Functional verification,,"Fill FIFO with known data. Initiate SPI read-data command. Monitor internal FIFO read pointer and read enable signals. Verify all FIFO read operations (pointer increment, data capture) occur synchronously to SCLK edges. Use waveform viewer to confirm no SAMPLE_CLK or HF_CLK domain signals directly trigger FIFO reads. Check CDC circuitry between SAMPLE_CLK (write) and SCLK (read) domains. Verify gray-code counters or async FIFO used for safe cross-domain access."
DIG-28,The FIFO writing shall be synchronous to the SAMPLE_CLK,,,Yes ,FIFO,,,,Initiate autonomous sampling mode. Monitor SAMPLE_CLK and FIFO write enable/pointer signals. Verify all FIFO write operations occur synchronously to SAMPLE_CLK domain (rising or falling edge as per design). Use waveform analysis to confirm write pointer increments and data latching align with SAMPLE_CLK. Verify no writes occur on SCLK or other clock domains. Check write-side CDC logic if FIFO is dual-clock. Ensure frame integrity during clock domain crossing.
DIG-29,The channel selection CHSEL<7:0> output to the AFE shall be multiplexed between the configured CHEN[7:0] register and the ATMCHSEL signal so that the device supports sequencing (turning ON/OFF) all channels in sequence so they are only powered on whilst the multiplexer is connected to that channel. ,,,Yes,ADC CONTROL,As in requirement,Functional verification,,"Write to CHAN_EN register with different bit patterns: 0x00 (all off), 0xFF (all on), 0x01, 0x02, 0x04...0x80 (individual channels), 0xAA, 0x55 (alternating). For each pattern, initiate sampling and verify only enabled channels are converted and appear in FIFO frame. Monitor mux select and ADC trigger signals - should only activate for enabled channels. Verify disabled channels produce no conversions and their FIFO slots remain zero (per MODE-11). Test dynamic reconfiguration mid-operation."
DIG-30,The device shall prevent writing to the configuration registers controlling the analogue domain whilst sampling is enabled. ,,,Yes,COMMAND INTEPRETER ,,,,"Disable sampling and write all the configuration registers - verifying that they can all be written correctly, Enable sampling and verify immediately that none of the configuration registers controlling the ADC, AFE, ATM, CREF, BIAS can be written to. Disable sampling and verify that all the configuration registers can only be correctly written to once sampling has completed"
DIG-31,The device shall ensure that complete frames of data are captured - i.e.when the enable sample signal is receivd the current frame is completed to ensure that the system is in a known state.,,,Yes,ADC CONTROL,,,,Verify that enabling and disabling sampling results in complete frames and the system stopping in a known good state
DIG-32,The device shall ensure that the clock division and gating is aligned with a sampling frame. ,,,Yes,ADC CONTROL,,,,Enable and disable sampling at different clock edges to verify that the clock division starts and remains frame aligned 
DIG-33,The analog front end shall provide eight amplifier channels multiplexed into a single ADC; the digital block shall control an 8:1 channel mux.,From specification.,,Yes,TLM,As in requirement,Functional verification,,Enable all 8 channels (CHAN_EN = 0xFF). Initiate sampling sequence. Monitor analog mux control signals (one-hot ATMCHSEL[7:0]). Verify mux select sequences through all 8 channels...Check correct sequencing. Verify each channel gets equal sampling time. Check mux control timing meets analog settling requirements. Test with partial channel enable to verify skipped channels.
DIG-34,"For each sampling instant, the digital shall convert all enabled channels and store them into the FIFO",Defines frame semantics.,,Yes,ADC CONTROL/FIFO,As in requirement,Functional verification,,"Use constrained-random sequences to generate varied CHAN_EN patterns (e.g., 3 channels, 5 channels, all 8). For each configuration, trigger one sampling instant. Monitor ADC conversion triggers - should see N triggers for N enabled channels. Verify FIFO receives exactly one complete frame with N samples. Use scoreboard to track: if CHAN_EN=0b00101101 (channels 0,2,3,5 enabled), expect 4 samples in frame. Verify frame completeness before DATA_READY asserts. Test frame boundaries are atomic."
DIG-35,Per-channel enable bits shall determine which channels participate; disabled channels shall not be converted.,Bandwidth and power optimisation.,,Yes,ADC CONTROL,As in requirement,Functional verification,,Set CHAN_EN = 0xFF (all enabled). Start sampling. Verify that all channels are sampled. Disable sampling. write CHAN_EN = 0xFE (disable channel 0). Resume sampling. Monitor ADC conversion triggers and mux select - channel 0 should be skipped in subsequent frames. Read FIFO and verify channel 0 position is 0x0000. Verify frame now contains only 7 samples. Test disabling multiple channels. Check power consumption reduces (fewer conversions). Test re-enabling channels. Verify clean transitions without glitches or partial conversions.
DIG-36,"The system shall support oversampling and noise shaping to increase effective resolution beyond the base ADC resolution (approximately 10\,bits up to approximately 16\,bits effective).",From specification. See ADC documentation for valid settings,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Program OSR_CFG register with different oversampling ratios (e.g., OSR=1,6,10,14,18). Apply known analog input (e.g., mid-scale DC). Capture multiple samples and calculate effective noise floor and ENOB (Effective Number of Bits). Verify: OSR=1 gives ~10 bits, higher OSR increases resolution toward 16 bits. Check ADC output word format - higher OSR should use more significant bits. Verify noise shaping filter characteristics if implemented. Test valid OSR settings per ADC spec; invalid settings should flag error or default."
DIG-37,"A sampling clock with a sampling frequency that is either a power of 2 or a multiple of 100 shall be derived from an external clock. 

A dual-phase gated burst divider in the HF_CLK domain shall generate the sampling clock in using a configurable 12 bit counter that divides the clock up to 8 times and then enters a second phase where a 10 bit counter counts HF_CLOCK clock cycles before rentering phase 1, (active burst and silent/alignment).",Based on updated Mode~2 description.,,Yes,BURST DIVIDER,As in requirement,Functional verification,,"Program 12-bit phase-1 counter (active burst) and 10-bit phase-2 counter (silent/alignment). Example: phase1=8 (divide-by-8), phase2=100 (100 HF_CLK cycles idle). Monitor SAMPLE_CLK output. Use assertions or counter to verify: Phase 1 produces exactly 8 SAMPLE_CLK pulses (for 8 channels). Phase 2 holds SAMPLE_CLK low for exactly 100 HF_CLK cycles. Total frame period = (8*—div + 100) HF_CLK cycles. Verify pattern repeats. Test multiple configurations. Calculate and verify resulting sampling frequency is power-of-2 or multiple of 100Hz."
DIG-38,"In Phase~1 of the burst divider, the block shall behave as an integer divider of the conversion clock, emitting one SAMPLE_CLK pulse per selected counter state until all channels are serviced.",Ensures deterministic spacing of sampling pulses.,,Yes,BURST DIVIDER,As in requirement,Functional verification,,"Enable N channels (e.g., N=5 via CHAN_EN=0b00011111). Configure phase-1 divider ratio (e.g., divide-by-4). Monitor SAMPLE_CLK during phase 1. Count SAMPLE_CLK pulses - should be exactly N pulses. Measure spacing between pulses - should be uniform (4 HF_CLK cycles if divide-by-4). Use checker/scoreboard to compare pulse count vs. enabled channel count. Verify phase 1 ends after Nth pulse. Test with different N (1 to 8 channels) and different divider ratios. Ensure deterministic, jitter-free pulse spacing."
DIG-39,"In Phase~2 of the burst divider, the SAMPLE_CLK output shall be gated low while the counter continues to run to complete a fixed-length frame in conversion-clock cycles.",Supports dead time and easier rate matching. Formulae/constraints linking clock division to OSR and channel count must be specified.,,Yes,BURST DIVIDER,As in requirement,Functional verification,,"After phase-1 completes (N SAMPLE_CLK pulses emitted), monitor transition to phase 2. Use assertions: assert property (phase2_active |-> SAMPLE_CLK == 0). Verify SAMPLE_CLK remains low for entire phase-2 duration (e.g., 100 HF_CLK cycles). Monitor internal phase-2 counter - should increment from 0 to programmed value while SAMPLE_CLK=0. Verify no glitches or spurious pulses on SAMPLE_CLK during silent phase. After phase-2 completes, verify clean transition back to phase 1. Check total frame length = phase1 + phase2 is constant and deterministic."
DIG-40,All SAMPLE_CLK edges shall be synchronous to HF_CLK via the counter to minimise cycle-to-cycle jitter.,Meets jitter requirements.,,Yes,BURST DIVIDER,As in requirement,Functional verification,,Monitor both HF_CLK and SAMPLE_CLK simultaneously. Use assertions to verify every SAMPLE_CLK edge (rising and falling) occurs coincident with an HF_CLK edge (same simulation delta or within gate delay). Example assertion: @(posedge SAMPLE_CLK) |-> @(posedge HF_CLK). Verify SAMPLE_CLK is derived purely from counter logic clocked by HF_CLK - no asynchronous generation. Check for glitches using glitch detection assertions (pulse width < min spec). Measure cycle-to-cycle jitter - should be quantized to HF_CLK period (no fractional jitter). Verify across all divider settings.
DIG-41,DELETED,,,No,,,,,N/A
DIG-42,The digital subsystem shall accept one or more digital indicator signals from the analog domain that assert when an amplifier channel is in saturation and shall log this condition and expose it to the external controller (e.g.\ via status registers and/or data frames).,Enables system-level detection of clipping/saturation events per channel.,"Exact mapping of saturation indicators to status bits and data-frame fields (granularity, per-channel vs.\ global) is TBD.",Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Use mixed-signal testbench or force/release to drive saturation indicator signals from analog domain (e.g., SAT[7:0], one per channel). Assert saturation on channel 3. Immediately read saturation status register - verify bit 3 is set. Check if saturation info is embedded in data frame (e.g., status bits in FIFO word). Test per-channel granularity. Verify sticky vs. real-time behavior. Clear saturation signal and check status updates. Test simultaneous saturation on multiple channels. Verify host can distinguish which channel(s) saturated."
DIG-43,The digital subsystem shall accept signals from the analog domain that represent the amplitude of the signal being received on each selected channel and shall make this information readable by the external controller (e.g.\ via status or debug registers).,Supports monitoring of per-channel signal amplitude without reconstructing full waveforms in the host.,"Signal format/bit-width, update rate, and whether amplitude is captured as peak, RMS, or other metric are TBD.",Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Drive known amplitude values from analog domain (e.g., AMP_CH0[7:0] = 0x7F for mid-scale). Read amplitude debug/status registers via SPI. Verify digital readback matches driven analog value. Test all 8 channels. Determine if amplitude is peak, RMS, or instantaneous. Check update rate - does it update every sample or periodically? Use scoreboard to track analog stimulus vs. digital readback. Test corner cases: zero amplitude, full-scale, rapid changes. Verify bit-width and format (unsigned, signed, etc.)."
DIG-44,The ADC input mux and sampling engine shall support routing an on-chip temperature sensor into the ADC so that the chip temperature can be measured by interleaving or otherwise multiplexing temperature conversions with normal channel conversions.,Allows monitoring of die temperature without a separate ADC or interface.,"Temperature-sampling cadence, configuration registers, and exact interaction with normal channel sequencing (e.g.\ dedicated temperature slots vs.\ occasional substitution) are TBD.",Yes,TLM,As in requirement,Functional verification,,"Enable temperature sensor in configuration register (e.g., TEMP_EN bit). Configure interleaving mode (e.g., read temp every Nth frame or dedicate channel 8 to temp). Monitor mux select - should occasionally route temp sensor instead of analog channel. Capture FIFO data and identify temperature samples (may have different format or position). Verify temperature data is reasonable (e.g., 20-40Â°C encoded value). Test that normal channel sampling continues correctly with temp interleaved. Verify frame structure with temp included. Check temp sampling cadence matches configuration."
DIG-45,SAMPLE_CLK jitter shall be less than 3ns ,,"Detailed jitter budget (including digital, clock source, and analog constraints) is TBD.",Yes,BURST DIVIDER,As in requirement,Timing analysis,,"Perform timing analysis on SAMPLE_CLK generation path. Use gate-level or transistor-level simulation with realistic clock source jitter model. Measure period variation across 1000+ cycles. Calculate peak-to-peak and RMS jitter. Verify pk-pk jitter <3ns. Check jitter sources: HF_CLK input jitter, divider logic delays, clock tree skew. If possible, use jitter analysis tool or oscilloscope measurement on silicon. Test across PVT corners. Verify jitter budget allocation between clock source and digital logic."
DIG-46,"The ADC output shall be presented as 16-bit words, ",From data-formatting section.,"For oversampled modes, mapping of analog full-scale to digital codes (offset-binary vs.\ two's complement) is TBD.",Yes,ADC CONTROL,As in requirement,Functional verification,,"Apply known analog inputs spanning full-scale range. Capture ADC output data. Verify all samples are 16-bit words (bits [15:0]). Check data format: two's complement, offset binary, or unsigned. Test with different OSR settings - all should produce 16-bit output. Verify no truncation or extension beyond 16 bits. Use scoreboard to mask and verify expected bit patterns. Test corner cases: zero-scale (0x0000 or 0x8000), mid-scale, full-scale positive and negative."
DIG-47,ADC output will always be left justified in bits e.g. when in 10 bit mode it will use bits [15:6] and bits [5:0] reserved/zero in non-oversampled modes. ,,This needs to be confirmed with the ADC documentation / Lieuwe. Does not impact on implementation,Yes,ADC CONTROL,As in requirement,Functional verification,,"Configure ADC for 10-bit mode (OSR=1 or base resolution). Apply known analog input. Read ADC output word. Verify bits [15:6] contain ADC data (10 bits). Verify bits [5:0] are always 0. Test with various input levels - data should appear in upper bits only. Repeat for other resolutions if applicable (e.g., 12-bit mode uses [15:4], [3:0]=0). Use bit-level scoreboard to mask lower bits and verify they're always zero. Test across different OSR settings to confirm left-justification rule."
DIG-48,The chip shall support 16 bit SPI words to read and write registers,From specification.,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,"Perform SPI write transaction: send 16-bit command word (R/W=write, address, opcode) followed by 16-bit data word. Verify register is written. Perform SPI read transaction: send 16-bit command word (R/W=read, address). Capture 16-bit response on MISO. Verify response matches register value. Test multiple registers. Verify all transactions use exactly 16-bit words (16 SCLK cycles per word). Test boundary cases: 0x0000, 0xFFFF, alternating patterns."
DIG-49,"The command word shall contain at least an R/W flag, an opcode field, and optionally an address field.",From TBD note in specification.,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,VErify that all command words opcodes are correctly decoded by the command interpreter
DIG-50,"The device shall support register write commands: command word with R/W = write, followed by a data word ",From specification.,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,"Send SPI transaction: Word 1 = command (R/W=write, address=MODE_CTRL). Word 2 = data (e.g., 0x00A5). Verify MODE_CTRL register is updated to 0x00A5. Use backdoor read or subsequent SPI read to confirm write succeeded. Test writing to multiple registers with different addresses. Test write to read-only register - should be ignored or flagged. Test write to reserved address - verify error handling. Use UVM RAL model to predict register state and compare."
DIG-51,The device shall support register read commands: command word with R/W = read; the device returns one or more 8-bit register values in the same transaction.,From specification.,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,Send a series of register read commands in a single SPI transaction. Verify registers return correct values. 
DIG-52,The device shall support a ``read data' command that streams out the current multi-channel frame,From specification.,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,"Fill FIFO with known data (e.g., 5 frames). Send SPI transaction: Word 1 = command (R/W=read, opcode=READ_FIFO). Word 2 to N+1 = dummy data. Monitor MISO for N data words. Verify MISO returns FIFO contents in correct order. Test reading single word, multiple words, and entire FIFO. Verify DATA_READY behavior during FIFO read. Test reading from empty FIFO (underflow condition). Use scoreboard to compare read data with expected FIFO contents."
DIG-53,The chip shall respond with an SPI word indicating the current status of the chip,From specification.,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,"Send SPI transaction: Word 1 = command (R/W=write, opcode=WRITE_FIFO). Word 2 to N+1 = known data words (e.g., 0x1234, 0x5678). Verify FIFO receives and stores the data. Use subsequent SPI read-FIFO command or backdoor access to verify data is correctly written into the FIFO. Test writing single word, multiple words, and filling the FIFO to capacity. Verify FIFO overflow behavior if writing beyond capacity. May use scoreboard to track FIFO contents."
DIG-54,"Outgoing data (sample frames) may be protected by CRC-16, appended as the final word of the SPI transaction.",From specification.,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,Apply known data into the FIFO and read it out over SPI - verify that once the Frame has been read that correct CRC data has been appended
DIG-55,Incoming commands shall not use CRC; robustness shall rely on host behaviour and optional read-back checks.,From specification (no inbound CRC).,,Yes,COMMAND INTERPRETER,As in requirement,Functional verification,,By design
DIG-56,An interrupt status pin may go high if there is a status change that needs to be communicated to the MCU,,,Yes,TLM,As in requirement,Functional verification,,Trigger all the variuos status bits individually and monitor that the interrupt pin is high when any or all are high. 
DIG-57,If DATA_READY is high the external controller shall read data by holding MOSI for the complete duration of SPI transactions (i.e. starting before CS goes low and ending after CS goes high again),,,Yes,COMMAND INTEPRETER ,As in requirement,Functional verification,,"Wait for DATA_READY to assert high. Before initiating SPI transaction, drive MOSI to defined state (high or low per spec). Assert CS low to start transaction. Monitor MOSI - should remain at same level throughout transaction (all SCLK cycles). Complete data read. Deassert CS high. Verify MOSI hold continues until after CS high. Use protocol checker to verify MOSI doesn't toggle during transaction. Test that this prevents bus contention or signaling issues. Verify data integrity with MOSI held constant."
DIG-58,"The register space shall be addressable via at least an 6-bit address, organised as a linear address map accessed over SPI.",From specification (8 bit address).,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Generate SPI transactions to access all addresses from 0x00 to 0x22 (6-bit = 34 addresses). For each address, perform write then read-back. Verify no decode errors or bus faults. Check that address space is linear (no gaps or aliasing). Test out-of-range addresses (0x23-0x4F (7-bit address) - should return error Test address decode logic for correctness."
DIG-59,Registers shall be grouped logically according to which part of the analogue/digital or ADC they configure and spare registers shall be included,Aids documentation and implementation.,Exact base addresses and block sizes for each group are TBD.,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,Review register address map documentation. Verify registers are grouped by function: Access spare registers - should read as 0x00 and writes should be ignored (or accepted for future use). Verify logical organization aids software driver development. Check that related registers are co-located for efficient burst access.
DIG-60,"The device shall implement MODE_CTRL, CLK_DIV_CONV, CLK_DIV_SAMP, OSR_CFG, CHAN_EN, and DATA_CTRL configuration registers at minimum.",From key configuration list.,"Full bitfield definitions, reset values, and access permissions (R/W/RO) are TBD.",Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,
DIG-61,"The device shall implement status registers STAT_GEN, STAT_DATA, and STAT_ERR for general, data-path, and error status.",From status section.,"Exact flag definitions, sticky vs.\ non-sticky semantics, and clear behaviour (e.g.\ write-1-to-clear) are TBD.",Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,
DIG-62,The map shall reserve FIFO_CTRL and FIFO_STAT registers for a future FIFO mode; these shall read as zero in first silicon.,Forward-compatibility.,Whether any bits must be tied to specific values for future compatibility is TBD.,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,
DIG-63,"On NRST assertion, all registers shall assume safe defaults: sampling disabled, all channels disabled.",From reset and OTP section.,"Full list of reset values, including clock dividers and OSR, is TBD.",Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,Duplicate
DIG-64,"After reset, an OTP load sequence may overwrite a subset of configuration and calibration registers with factory-programmed values.",From OTP section.,Exact precedence rules (OTP vs.\ hard reset vs.\ software writes) and list of OTP-overridable registers are TBD.,No,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"For each R/W register: write a known pattern (e.g., 0xA5A5), then read back. Verify read value matches written value. For each RO register: attempt to write a non-zero value, then read back. Verify read value is unchanged (or 0x0000 if tied off). For each WO register: write a known pattern, then attempt to read back. Verify read returns 0x0000 or an undefined value (as per spec). Use UVM RAL access tests (e.g., bit-bash, walking-1s/0s) to verify permissions for all registers."
DIG-65,Spare registers for each group of registers shall be included,,,,,,,,"Review register map for each functional group (mode, clock, ADC, status, etc.). Access spare registers - should be readable and writable (or read as zero if tied off). Document spare register addresses for future expansion. "
DIG-66,"The device may perform a CRC (preferred) or Fletcher hash of the configuration register values to detect any random changes / errors in setting registers (except the status register, the reset register and the saturation register which are all monitored separately)",,Low priority,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"If CRC/hash feature implemented: Read initial hash value from hash register. Write to configuration register Read hash register again - value should change. Calculate expected hash over all config registers (excluding status, reset, saturation regs per spec). Compare calculated vs. read hash - should match. Test that changing different registers produces different hashes. Verify status/reset/saturation registers excluded from hash. Use hash to detect unintended register corruption during operation."
DIG-67,The device may provide a means to read out the CRC / Fletcher hash ,,Low priority,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"If hash readout implemented: Identify hash readout register (e.g., CFG_HASH at address 0xXX). Write known configuration values to all config registers. Manually calculate expected CRC-16 or Fletcher hash over config register values using same algorithm as design. Read CFG_HASH register via SPI. Compare read value with manually calculated hash - should match. Test with different config combinations. Verify hash updates in real-time as config changes. Use hash readout for integrity checking in production test or field diagnostics."
DIG-68,The device may provide a status flag that indicates the CRC / Fletcher hash has changed,,Low priority,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"If hash-changed flag implemented: Read initial hash and hash-changed status flag (should be clear). Modify configuration register. Read hash-changed flag - should now be set, indicating config change detected. Read hash value to clear flag (if read-to-clear) or explicitly clear flag. Verify flag clears. Test that flag sets whenever any config register changes. Verify flag doesn't set when excluded registers (status, etc.) change. Use flag to trigger interrupt or alert host of unexpected config changes (e.g., due to SEU or corruption)."
DIG-69,"The digital subsystem shall define distinct clock domains: SPI (SCLK), core/conversion (HF_CLK-derived), and scan/test (SCAN_CLK).",From clock-domain section.,,Yes,TLM,As in requirement,Functional verification,,"Operate all three clock domains simultaneously with different frequencies. Example: SCLK=10MHz, HF_CLK=8MHz (conversion domain), SCAN_CLK=1MHz. Verify each domain operates independently - no frequency locking or interference. Use CDC analysis tool to identify all clock domain crossings. Verify proper synchronization at each crossing (2-FF sync, handshake, async FIFO). Monitor for metastability or data corruption. Test with varying clock ratios. Verify no combinational paths cross domains without synchronization."
DIG-70,CLK_DIV_CONV shall divide HF_CLK by a coarse factor (power of two) and then an integer $N \ge 1$ to produce the conversion clock.,From specification.,"Exact divider implementation, range of $N$, and allowed combinations are TBD.",Yes,BURST DIVIDER,As in requirement,Functional verification,,"Program CLK_DIV_CONV register with coarse divider (e.g., /4) and fine divider N (e.g., N=3). Monitor HF_CLK and conversion clock outputs. Count edges to measure actual divide ratio. Example: coarse=/4, N=3 should give total division of 12. Verify conversion clock frequency = HF_CLK / (coarse Ã— N). Test range of N values (1 to max). Test different coarse factors (1,2,4,8...). Verify only integer division - no fractional behavior. Check duty cycle of output clock."
DIG-71,CLK_DIV_SAMP shall divide the conversion clock by an integer $M \ge 1$ to produce the sampling clock in Mode~2.,From specification (in addition to gated-burst behaviour).,Interaction between burst-divider configuration and CLK_DIV_SAMP (if both exist) is TBD.,Yes,BURST DIVIDER,As in requirement,Functional verification,,"Program CLK_DIV_SAMP register with M value (e.g., M=5). Monitor conversion clock and SAMPLE_CLK. Count conversion clock edges between SAMPLE_CLK edges. Verify ratio is exactly M:1. Test range of M (1 to max allowed). Verify M=1 gives 1:1 (SAMPLE_CLK = conversion clock). Test interaction with burst divider if both exist - verify they work together correctly or are mutually exclusive modes. Check SAMPLE_CLK duty cycle and edge alignment."
DIG-72,Fractional-$N$ division shall not be used to avoid additional jitter and design complexity.,From specification.,Confirm there are no corner cases that effectively create fractional behaviour (e.g.\ pulse swallowing).,Yes,BURST DIVIDER,As in requirement,Functional verification,,"Test all divider configurations across full range of settings. For each configuration, measure output clock frequency over extended period (1000+ cycles). Calculate average divide ratio. Verify ratio is always an integer (e.g., 2.0, 5.0, 12.0) never fractional (e.g., 2.5, 3.33). Check for pulse swallowing or dithering techniques that could create effective fractional division. Inspect RTL to confirm no fractional-N logic. Verify jitter is quantized to input clock period, not smoothed over multiple cycles."
DIG-73,Overall sampling jitter shall not exceed approximately \SI{25}{ns} in the highest-performance configuration; looser limits may apply in lower-performance modes.,From specification.,Precise jitter budgets per mode/OSR and how they map into RTL constraints and verification are TBD.,Yes,BURST DIVIDER,As in requirement,Timing analysis,,"Configure system for highest-performance mode (max sampling rate, min OSR). Measure SAMPLE_CLK jitter using gate-level simulation with SDF or on silicon with oscilloscope/TIA. Capture 1000+ SAMPLE_CLK periods. Calculate period variation: pk-pk jitter and RMS jitter. Verify pk-pk jitter <25ns. Identify jitter contributors: HF_CLK source, divider logic, clock distribution. Test across PVT corners. For lower-performance modes, verify jitter is within relaxed limits. Document jitter vs. performance tradeoff."
DIG-74,NRST shall asynchronously reset all digital state; internal synchronisers shall ensure clean release into each clock domain.,From reset-strategy section.,"Detailed reset tree, any local soft resets, and their exact behaviour are TBD.",Yes,TLM,As in requirement,Functional verification,,"Assert NRST asynchronously (not aligned to any clock). Verify all flip-flops reset immediately. Release NRST. Monitor reset release in each clock domain (SCLK, HF_CLK, SCAN_CLK). Verify reset synchronizers (2-FF chains) in each domain provide clean, glitch-free release synchronized to local clock. Use waveform viewer to check no metastability or X states. Test reset assertion/release at various phases relative to clocks. Verify no race conditions between domains during reset release. Check reset tree fanout and buffering."
DIG-75,"In the baseline (no FIFO) configuration, the device shall buffer only the latest complete frame (all enabled channels).",From specification.,Whether partial frames can ever be visible to the host must be explicitly ruled out.,Yes,ADC CONTROL,As in requirement,Functional verification,,"Disable FIFO mode (baseline configuration). Enable multiple channels. Trigger sampling to generate frame 1 (e.g., all channels = 0x1111). Before host reads, trigger frame 2 (all channels = 0x2222). Host reads buffer via SPI. Verify only frame 2 is returned (latest complete frame). Frame 1 should be overwritten. Test that partial frames are never visible - if frame 3 is incomplete when host reads, frame 2 should still be returned. Verify atomic frame updates."
DIG-76,"If a new frame completes before the previous one is read, the older frame shall be overwritten and the host shall see only the most recent frame.",Defined behaviour for overrun without FIFO.,Whether an overrun status flag is mandatory in first silicon is TBD.,Yes,ADC CONTROL,As in requirement,Functional verification,,"In baseline (no-FIFO) mode, generate frames rapidly without host reads. Frame 1 completes, then frame 2, then frame 3. Host finally reads buffer. Verify frame 3 is returned (most recent). Frames 1 and 2 were overwritten. Check if overrun status flag exists - if so, verify it's set to indicate frames were lost. Test that overwrite behavior is deterministic and doesn't corrupt data. Verify host always gets complete, valid frame (newest one), never mixed/partial data."
DIG-77,"A future FIFO mode shall be supportable with at least 16-frame depth; on overflow, the oldest unread frame is dropped and a status flag is set.",From future FIFO description.,Whether any FIFO features will be pulled into first silicon must be decided early.,Yes,FIFO,As in requirement,Functional verification,,"If FIFO mode implemented: Enable FIFO mode. Verify FIFO depth is at least 16 frames. Fill FIFO with 16 frames without reading. Verify DATA_READY asserts. Generate frame 17 to cause overflow. Read FIFO - should get frames 2-17 (frame 1 dropped, oldest). Verify overflow status flag is set. Test FIFO read/write pointers wrap correctly. Test partial fill/drain scenarios. Verify FIFO behavior matches circular buffer semantics. If not in first silicon, verify FIFO_CTRL/FIFO_STAT reserved for future."
DIG-78,"The digital design shall target full scan coverage of synchronous storage elements where practical, using dedicated scan control pins.",From DFT section.,Non-scannable elements and justifications must be enumerated and agreed.,Yes,TLM,As in requirement,Functional verification,,"Insert DFT scan chains using synthesis tool. Generate scan coverage report. Verify >95% of flip-flops are in scan chains. Identify non-scannable elements (e.g., async reset FFs, clock dividers, RAMs) and document justification. Use SCAN_EN, SCAN_CLK, SCAN_IN, SCAN_OUT pins to shift test patterns. Verify scan chain integrity - shift known pattern in, capture, shift out, compare. Run ATPG to generate fault coverage patterns. Simulate patterns and verify fault coverage >95%. Check scan chains don't affect functional mode (SCAN_EN=0)."
DIG-79,The design shall not rely on at-speed digital test at maximum SPI/clock rates; functional tests may run at reduced speeds.,From production-test description.,Any exceptions (paths requiring at-speed validation) are TBD.,Yes,N/A,As in requirement,Functional verification,,"Run full functional test suite (register access, sampling, FIFO, etc.) at reduced clock speeds: SCLK=1MHz (vs. 15MHz max), HF_CLK=1MHz (vs. 8MHz max). Verify all tests pass at reduced speed. Confirm no at-speed requirements for production test (except maybe final characterization). Identify any critical paths that must be tested at-speed (e.g., setup/hold on specific interfaces) - these should be exceptions, not the norm. Verify production test can be performed with low-cost, slow ATE."
DIG-80,No dedicated digital pattern generators or loopback modes are currently planned beyond what can be driven via SPI and scan.,From specification.,Need to confirm whether any simple loopback or BIST features are required for system debug.,Yes,N/A,As in requirement,Functional verification,,By design
DIG-81,"RTL shall follow clean synchronous design practices, with one active clock per domain and no inferred latches.",From design guidelines.,Coding guidelines and LINT ruleset/tool choice are TBD.,Yes,ALL,As in requirement,Functional verification,,"Run lint tool on all RTL. Check for violations: inferred latches, multiple clocks to single FF, combinational loops, uninitialized variables. Verify lint report shows zero latches. Review clock usage - each FF should have single clock source within its domain. Check for clock muxing - should use glitch-free clock mux cells if present. Verify all always blocks use proper sensitivity lists (or always_ff/always_comb in SystemVerilog). Achieve clean lint with zero critical warnings."
DIG-82,All asynchronous inputs (including NRST and cross-domain controls) shall be properly synchronised to their destination domains.,From design guidelines.,Concrete CDC methodology (two-flop synchroniser vs.\ handshake vs.\ FIFO per path) is TBD.,Yes,ALL,As in requirement,Functional verification,,"Run Clock domain crossing analysis tool Identify all clock domain crossings and async inputs. For each crossing, verify proper synchronization: 2-FF synchronizer for single-bit signals, handshake for control, async FIFO or gray-code for multi-bit data. Check NRST has sync chain in each domain. Verify no direct async-to-logic paths. Review Clock Domain Crossing report - should show all crossings are properly handled with zero violations. Test metastability recovery with simulation (force X on sync FF, verify resolves)."
DIG-83,Low-power design shall use explicit clock-gating cells where needed and avoid unnecessary switching.,From specification.,Power-budget targets and whether any power domains beyond digital core exist are TBD.,Yes,ALL,As in requirement,Functional verification,,"Synthesize design with clock-gating enabled. Review netlist for clock-gating cells (e.g., CKLNQD1, ICG cells). Verify clock-gating on idle blocks: disabled channels, empty FIFO, inactive modes. Run gate-level power simulation with realistic activity. Measure dynamic power with and without clock-gating - verify significant reduction (e.g., 20-40%). Check for unnecessary toggle activity on unused signals. Verify clock-gating doesn't introduce functional bugs (glitches, race conditions). Test across different operating modes and channel configurations."
DIG-84,"Verification shall cover all modes, SPI commands, OSR configurations, and key error scenarios, using directed plus constrained-random tests as needed.",From verification principles.,"Coverage goals (functional, code, assertion) and acceptable thresholds are TBD.",Yes,TLM,As in requirement,Functional verification,,"Develop comprehensive verification plan covering: all operating modes (periodic, autonomous, FIFO), all SPI commands (read/write reg, read data, status), all OSR settings, all channel enable combinations, error cases (overflow, underflow, saturation, OTP fail). Implement directed tests for basic functionality. Implement constrained-random tests for corner cases and stress testing. Collect functional coverage on modes, commands, configs. Collect code coverage (line, branch, toggle, FSM). Target >90% functional coverage, >95% code coverage. Review coverage holes and add tests to close gaps."
DIG-85,"Assertions shall check protocol correctness (SPI framing, commands, DATA_READY), reset behaviour, and safety properties (no illegal state transitions).",From verification principles.,List of mandatory properties and where they are implemented (testbench vs.\ assertions in RTL) is TBD.,Yes,TLM,As in requirement,Functional verification,,"Implement assertions for: SPI protocol (CS/SCLK relationship, 16-bit words, no glitches), DATA_READY semantics (asserts when FIFO above watermark), reset behavior (all FFs reach reset state), FSM safety (no illegal state transitions, no deadlocks), clock relationships (SAMPLE_CLK sync to HF_CLK), one-hot encoding (ATMCHSEL). Enable assertions during all simulations. Verify zero assertion failures in regression. Use assertion coverage to ensure properties are exercised. Implement both in RTL (synthesizable) and testbench (for checking)."
DIG-86,Provide a status flag that one of the channels is being reset,,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Trigger channel reset condition (e.g., write to channel reset register or assert analog reset signal). Immediately read channel status register. Verify 'channel reset' flag is set. Determine if flag is per-channel (8 bits, one per channel) or global (single bit, any channel resetting). Test resetting different channels - verify correct flag(s) set. Check flag behavior: real-time (clears when reset completes) or sticky (requires explicit clear). Verify host can poll this flag to know when channel is ready."
DIG-87,Provide a status flag that one of the channels has gone into saturation,,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Drive analog saturation signal for channel 3 (SAT[3]=1). Read saturation status register. Verify bit 3 is set indicating channel 3 saturated. Test all 8 channels individually. Test multiple simultaneous saturations - verify multiple bits set. Check if flag is real-time (follows SAT signal) or latched (sticky until cleared). If sticky, test clear mechanism. Verify saturation flag is separate from saturation log register (STS-3). This flag shows current/recent saturation state."
DIG-88,Provide saturation registers that log (sticky bit) that a channel has gone into saturation,,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Drive saturation on channel 5 (SAT[5]=1). Read saturation log register - verify bit 5 is set (sticky). Remove saturation signal (SAT[5]=0). Read log register again - bit 5 should still be set (sticky behavior). Test clearing: write-1-to-clear or dedicated clear command. Verify bit 5 clears. Test saturation on multiple channels over time - log register should accumulate all saturation events (OR of all events since last clear). Use log to detect any saturation occurrence during measurement period, even if transient."
DIG-89,Provide a status bit that the ADC has gone into overflow,,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,Apply analog input that exceeds ADC full-scale range to cause ADC overflow. Read ADC status register. Verify overflow bit is set. Determine if overflow is per-channel or global. Test overflow on different channels. Check if overflow refers to ADC conversion overflow (analog too large) vs. FIFO overflow (different from MODE-7). Verify overflow flag behavior: sticky or real-time. Test clearing mechanism. Verify overflow doesn't corrupt ADC data - should clip to max value (0xFFFF or 0x7FFF depending on format).
DIG-90,Provide a status bit that ADC data has been overwritten / read opportunity was missed (FIFO FULL),,,Yes,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"In baseline (no-FIFO) mode or with FIFO enabled: generate data faster than host reads. In baseline mode, new frame overwrites old frame. In FIFO mode, fill FIFO to capacity. Continue generating data to cause overwrite/FIFO-full condition. Read status register - verify 'data overwritten' or 'FIFO full' bit is set. Test that flag indicates host missed read opportunity (data loss). Verify flag is sticky and can be cleared. Use flag to detect data loss and alert host to increase read rate or reduce sampling rate."
DIG-91,,,,,,,,,
DIG-92,"OTP memory may store factory-programmed calibration and configuration values, with an approximate budget of up to around 512\,bits.",From specification.,Final OTP bit budget and organisation are TBD.,No,OTP,As in requirement,Functional verification,,"If OTP included: Program OTP with test pattern using up to 512 bits. Example: 256 bits calibration data + 256 bits config/redundancy. Read back OTP contents via test interface or after reset (OTP auto-load). Verify all programmed bits match. Test OTP capacity - verify 512 bits can be stored and retrieved. Check OTP organization (words, bytes, bit-fields). Verify OTP is non-volatile (retains data across power cycles in simulation model). Test OTP programming flow and read access timing."
DIG-93,"OTP content may include global trims (e.g.\ reference/ADC gain/offset) and per-channel calibration values, plus optional configuration defaults (e.g.\ OSR, mode).",From OTP content description.,Exact bit allocation per field and required precision per trim are TBD.,No,OTP,As in requirement,Functional verification,,"Program OTP with structured data: global gain trim (8 bits) = 0x7C, global offset (8 bits) = 0x05, per-channel offsets (8 channels Ã— 4 bits = 32 bits), default OSR (4 bits) = 0x3, default mode (4 bits) = 0x1. After reset with OTP load, read corresponding registers via SPI. Verify: gain register = 0x7C, offset = 0x05, channel cal registers match per-channel values, OSR_CFG = 0x3, MODE_CTRL = 0x1. Test that OTP structure matches register map. Verify bit allocation is efficient and documented."
DIG-94,"After NRST deassertion, the digital block mayread OTP and apply valid overrides to the corresponding registers before normal operation begins.",From startup sequence.,"Timeout behaviour, error detection (e.g.\ CRC/parity of OTP) and fall-back behaviour are TBD.",No,TLM,As in requirement,Functional verification,,"Program OTP with known values. Assert then release NRST. Monitor OTP read sequence - should start automatically after reset release. Use waveform viewer or status flags to track OTP read progress. Verify OTP read completes before any sampling or normal operation begins. After OTP load done, read affected registers - should contain OTP values. Test timeout: if OTP read hangs, verify system times out and proceeds with defaults. Check for OTP valid flag or CRC - if invalid, verify fallback to defaults."
DIG-95,"If OTP read is conducted and fails or is blank/invalid, defaults may remain in effect and an error flag shall be set in a status register; the device may still operate with default trims.",From specification.,"Exact error-flag location, latching/clearing semantics, and any derating requirements are TBD.",No,CONFIGURATION REGISTERS,As in requirement,Functional verification,,"Simulate OTP failure scenarios: blank OTP (all 0s or all 1s), corrupted CRC, read timeout. After reset with failed OTP load, read status register (e.g., STAT_ERR). Verify OTP error flag is set. Read configuration registers - should contain hard reset defaults, not garbage. Verify system operates normally with default trims (may have reduced performance/accuracy). Test that error flag is sticky and can be cleared. Verify host can detect OTP failure and take corrective action (e.g., load software calibration)."
