{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pepper_T4 Digital Documentation","text":"<p>This is the technical documentation for the Pepper_T4 Digital Logic, a mixed-signal controller system designed to interface an external host via SPI with an 8 channel Analog Front End (AFE) and ADC.</p>"},{"location":"#what-is-pepper_t4","title":"What is Pepper_T4?","text":"<p>Pepper_T4 digital manages configuration, timing generation, and high-speed data buffering across two primary clock domains: - SCK Domain: SPI clock domain for command interpretation and register access - HF_CLK Domain: High-frequency system clock for ADC, AFE control, and status monitoring</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#system-overview","title":"System Overview","text":"<p>High-level theory of operation, data flow architecture, and key system constraints. Start here to understand how the system functions as an SPI slave and the interaction between major blocks.</p> <ul> <li>Block Diagram - Top-level module interconnections and IO ports</li> </ul>"},{"location":"#core-blocks","title":"Core Blocks","text":"<p>Detailed documentation for the critical building blocks:</p> <ul> <li>Command Interpreter - Main FSM controlling SPI commands and register access</li> <li>FIFO - Asynchronous dual-clock FIFO for ADC data buffering</li> <li>CDC Sync - Clock domain crossing synchronizers</li> </ul>"},{"location":"#functional-logic","title":"Functional Logic","text":"<p>Status monitoring, error handling (overflow, underflow, saturation), and reset architecture.</p>"},{"location":"#peripherals","title":"Peripherals","text":"<p>Register maps and peripheral control logic:</p> <ul> <li>ATM Control - Analog Test Mux controller</li> <li>Configuration Registers - Complete register map and bit field definitions</li> <li>Temperature Sensor - On-chip temperature sensor control</li> </ul>"},{"location":"#building-the-documentation","title":"Building the Documentation","text":"<p>To view this documentation locally with live reload:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then navigate to <code>http://127.0.0.1:8000</code> in your browser.</p> <p>To build a static site:</p> <pre><code>mkdocs build\n</code></pre> <p>The static files will be generated in the <code>site/</code> directory.</p> <p>Navigation Tips</p> <p>Use the tabs above to browse by section, or use the search bar (top right) to find specific modules or topics.</p>"},{"location":"system_overview/","title":"System Overview","text":""},{"location":"system_overview/#introduction","title":"Introduction","text":"<p>Pepper T4 digital logic is a mixed-signal controller system designed to interface an external host (via SPI) with an 8 channel Analog Front End (AFE) and ADC. It manages configuration, timing generation (<code>SAMPLE_CLK</code>), and high-speed data buffering.</p> <p>The digital core operates on two primary clock domains: *   SCK Domain: The SPI clock domain, used for command interpretation and register access. *   HF_CLK Domain: The high-frequency system clock, used for the ADC, AFE control, and status monitoring.</p>"},{"location":"system_overview/#theory-of-operation","title":"Theory of Operation","text":"<p>The system functions as an SPI Slave. The data flow is as follows:</p> <ol> <li>Command Phase: The Host sends a command byte via SPI.<ul> <li>The <code>spiCore</code> deserializes this into <code>cmd_byte</code>.</li> <li>The <code>Command_Interpreter</code> parses the opcode (Read Reg, Write Reg, Read Data).</li> </ul> </li> <li>Execution Phase:<ul> <li>Register Write: Data is written to <code>Configuration_Registers</code>. If the target is in the <code>HF_CLK</code> domain, it is synchronized via <code>CDC_sync</code>.</li> <li>Register Read: Data is retrieved from <code>Configuration_Registers</code> or <code>Status_Monitor</code> and loaded into the <code>tx_buff</code> for transmission.</li> <li>Data Read: ADC samples are popped from the <code>FIFO</code> and streamed to the host.</li> </ul> </li> </ol>"},{"location":"system_overview/#polling-vs-interrupts","title":"polling vs Interrupts","text":"<p>The system provides 2 hardware interrupt pins (<code>DATA_RDY</code> and <code>INT</code>). <code>DATA_RDY</code> asserts when the internal FIFO has a number of frames of data available to read. <code>INT</code> asserts when any error flag (Overflow, Underflow, Saturation) is set. Alternatively, the Host can poll the Status Register (returned as the first byte of every transaction) to monitor system health.</p>"},{"location":"system_overview/#key-limitations-constraints","title":"Key Limitations &amp; Constraints","text":"<p>Write Protection during Sampling</p> <p>To prevent glitches and meta-stability issues, Configuration Register writes are BLOCKED when Sampling is Active (<code>ENSAMP=1</code>).</p> <p>Attempts to write to registers 0x00-0x22 will be ignored by the hardware while <code>ENSAMP</code> is high, with the following exceptions (Safe Registers): *   0x12: <code>AFERSTCH</code> (Allows resetting channels dynamically). *   0x13: Buffer/LNA control (Safe for dynamic updates). *   0x23: Contains <code>ENSAMP</code> itself (allows disabling sampling).</p> <p>Procedure to change configuration: 1.  Write <code>0x00</code> to Register <code>0x23</code> (Disable Sampling). 2.  Poll Status to confirm <code>ENSAMP</code> flag is low. 3.  Perform configuration writes. 4.  Write <code>0x80</code> to Register <code>0x23</code> (Enable Sampling).</p> <p>Procedural Limitation: FIFO Readout Boundary</p> <p>After writing <code>ENSAMP=0</code> (Disable Sampling), the MCU MUST end the current SPI transaction (raise CS) before issuing any <code>RDDATA</code> commands.</p> <p>If you attempt to read from the FIFO immediately after writing <code>ENSAMP=0</code> within the same transaction, the data returned is undefined. The disable-to-read sequence requires a transaction boundary to reset internal pointers correctly.</p>"},{"location":"system_overview/#internal-block-summary","title":"Internal Block Summary","text":"Module Description spiCore Physical layer interface for 4-wire SPI (Mode 0). Command_Interpreter Main FSM. Parses SPI commands, controls FIFO readout, and manages Register/Status access. Configuration_Registers Stores the 512-bit configuration state. Maps SPI registration addresses to physical control signals. CDC_sync Clock Domain Crossing. Safe transfer of control signals (SCK -&gt; HF_CLK) and status flags (HF_CLK -&gt; SCK). Dual_phase_gated_burst_divider Generates the precise <code>SAMPLE_CLK</code> from <code>HF_CLK</code> based on configured dividers. FIFO Asynchronous FIFO buffering ADC data (HF_CLK domain) for SPI readout (SCK domain). Status_Monitor Aggregates error flags (Overflow, Saturation) and system state into a unified status register. ATM_Control Analog Test Mux controller. Sequences channel selection signals aligned with ADC conversion windows. TempSense Controls the on-chip temperature sensor and its specialized readout sequence."},{"location":"core_blocks/cdc_sync/","title":"CDC_sync Module Documentation","text":""},{"location":"core_blocks/cdc_sync/#overview","title":"Overview","text":"<p>The <code>CDC_sync</code> module provides Clock Domain Crossing (CDC) synchronization for signals crossing from the SPI clock domain (or other source domains) into the high-frequency clock domain (<code>HF_CLK</code>). It implements multiple synchronization strategies tailored to different signal types and timing requirements.</p> <p>File Location: CDC_sync.v</p>"},{"location":"core_blocks/cdc_sync/#synchronization-mechanisms","title":"Synchronization Mechanisms","text":""},{"location":"core_blocks/cdc_sync/#1-standard-2-flip-flop-synchronizer-level-synchronization","title":"1. Standard 2-Flip-Flop Synchronizer (Level Synchronization)","text":"<p>Most control signals use a 2-stage flip-flop synchronizer chain, which is the industry-standard approach for synchronizing level signals across clock domains.</p> <p>Signals using this mechanism: - <code>ENSAMP</code> \u2192 <code>ENSAMP_sync</code> - <code>ENLOWPWR</code> \u2192 <code>ENLOWPWR_sync</code> - <code>ENMONTSENSE</code> \u2192 <code>ENMONTSENSE_sync</code> - <code>ADCOVERFLOW</code> \u2192 <code>ADCOVERFLOW_sync</code> - <code>ADCOVERFLOW</code> \u2192 <code>ADCOVERFLOW_sync</code> - <code>CFG_CHNGE</code> \u2192 <code>CFG_CHNGE_sync</code> (Conditional: enabled via <code>ENABLE_REGISTER_CRC</code>) - <code>AFERSTCH[7:0]</code> \u2192 <code>AFERSTCH_sync[7:0]</code> - <code>AFERSTCH[7:0]</code> \u2192 <code>AFERSTCH_sync[7:0]</code> - <code>SATDETECT[7:0]</code> \u2192 <code>SATDETECT_sync[7:0]</code></p> <p>How it works: <pre><code>graph LR\n    A[Input Signal&lt;br/&gt;Source Domain] --&gt; B[DFF Stage 1&lt;br/&gt;Metastability Filter]\n    B --&gt; C[DFF Stage 2&lt;br/&gt;Stable Output]\n    C --&gt; D[Synchronized Output&lt;br/&gt;Destination Domain]\n\n    style B fill:#ff9,stroke:#333,stroke-width:2px\n    style C fill:#9f9,stroke:#333,stroke-width:2px</code></pre></p> <p>The first flip-flop may enter a metastable state, but the second flip-flop resolves this to a stable logic level before the signal is used. This provides reliable level synchronization with 2 clock cycles of latency.</p>"},{"location":"core_blocks/cdc_sync/#2-toggle-to-pulse-converter","title":"2. Toggle-to-Pulse Converter","text":"<p>The FIFO overflow and underflow signals use a special toggle synchronization approach followed by edge detection to generate single-cycle pulses in the destination domain.</p> <p>Signals using this mechanism: - <code>FIFO_OVERFLOW</code> \u2192 <code>FIFO_OVERFLOW_sync</code> - <code>FIFO_UNDERFLOW</code> \u2192 <code>FIFO_UNDERFLOW_sync</code></p> <p>How it works:</p> <p>The source domain toggles the signal for each event. The destination domain: 1. Synchronizes the toggling signal through a 2-FF chain 2. Compares current value with previous value (XOR operation) 3. Generates a 1-cycle pulse on each detected edge</p> <pre><code>graph LR\n    A[Toggle Input&lt;br/&gt;Source Domain] --&gt; B[DFF Stage 1]\n    B --&gt; C[DFF Stage 2]\n    C --&gt; D[XOR]\n    E[Previous Value] --&gt; D\n    D --&gt; F[1-Cycle Pulse Output]\n    C --&gt; E\n\n    style D fill:#f99,stroke:#333,stroke-width:2px\n    style F fill:#9f9,stroke:#333,stroke-width:2px</code></pre> <p>This approach allows events in a slow source domain to be reliably captured in a fast destination domain, even if multiple events occur between destination clock edges.</p>"},{"location":"core_blocks/cdc_sync/#3-asynchronous-assert-synchronous-deassert-reset","title":"3. Asynchronous Assert, Synchronous Deassert (Reset)","text":"<p>The reset signal <code>NRST</code> uses a special CDC technique appropriate for reset signals: - Asynchronous assertion: When <code>NRST</code> goes low, the synchronized reset immediately goes low - Synchronous deassertion: When <code>NRST</code> goes high, it's synchronized through 2 FFs before releasing reset</p> <p>This ensures reset is applied immediately but released cleanly without metastability.</p>"},{"location":"core_blocks/cdc_sync/#4-direct-pass-through-area-optimization","title":"4. Direct Pass-Through (Area Optimization)","text":"<p>Some configuration buses are not synchronized and passed directly through: - <code>PHASE1DIV1[11:0]</code> - <code>PHASE1COUNT[3:0]</code> - <code>PHASE2COUNT[9:0]</code> - <code>CHEN[7:0]</code> - <code>ADCOSR[3:0]</code></p> <p>[!CAUTION] Multi-bit CDC Hazard!</p> <p>These signals are passed through without synchronization to save area. The system MUST ensure these configuration registers are only modified when <code>ENSAMP</code> is low (sampling disabled). Changing multi-bit values during operation can cause incorrect intermediate values to be sampled due to skew between bits.</p>"},{"location":"core_blocks/cdc_sync/#timing-constraints","title":"Timing Constraints","text":""},{"location":"core_blocks/cdc_sync/#input-pulse-width-requirements","title":"Input Pulse Width Requirements","text":"<p>[!WARNING] Critical Timing Constraint for Toggle Synchronization</p> <p>For the <code>FIFO_OVERFLOW</code> and <code>FIFO_UNDERFLOW</code> toggle-based synchronizers to guarantee event capture, the input signal must maintain each toggle state for a minimum duration to ensure it is sampled by the destination clock.</p> <p>Minimum Pulse Width Rule: <pre><code>T_input_stable \u2265 T_dest_clk + T_setup + T_meta\n</code></pre></p> <p>Where: - <code>T_input_stable</code> = Duration the input toggle state must remain stable - <code>T_dest_clk</code> = Destination clock period (HF_CLK) - <code>T_setup</code> = Setup time of the destination flip-flops - <code>T_meta</code> = Metastability resolution time allowance</p> <p>Practical Rule: The input should remain stable for at least 1.5\u00d7 to 2\u00d7 the destination clock period to guarantee reliable capture.</p> <p>Example: If <code>HF_CLK</code> = 1 MHz (1 us period), the FIFO overflow/underflow toggle should remain in each state for \u2265 1.5-2 us minimum.</p>"},{"location":"core_blocks/cdc_sync/#level-synchronizer-constraints","title":"Level Synchronizer Constraints","text":"<p>For the standard 2-FF synchronizers (<code>ENSAMP</code>, <code>ENLOWPWR</code>, etc.):</p> <p>Input Stability Requirement: - Level signals should be quasi-static (change infrequently relative to destination clock) - Signal must remain stable for at least one full destination clock cycle to guarantee capture - Faster changes may be captured with variable latency (2-3 destination clock cycles)</p> <p>[!IMPORTANT] Multi-bit buses like <code>AFERSTCH[7:0]</code> and <code>SATDETECT[7:0]</code> are synchronized bit-independently. To avoid capturing intermediate values during transitions: - Keep these buses stable for multiple destination clock cycles when changing - Use gray-code encoding if values must change rapidly - OR ensure the source domain changes bits simultaneously (same clock edge)</p>"},{"location":"core_blocks/cdc_sync/#block-diagram","title":"Block Diagram","text":"<pre><code>graph TB\n    subgraph \"Inputs - Source Domain\"\n        IN1[ENSAMP]\n        IN2[ENLOWPWR]\n        IN3[AFERSTCH 7:0]\n        IN4[FIFO_OVERFLOW]\n        IN5[FIFO_UNDERFLOW]\n        IN6[NRST]\n        IN8[CFG_CHNGE]\n        IN7[PHASE1DIV1 11:0&lt;br/&gt;Direct Pass-through]\n    end\n\n    subgraph \"2-FF Level Synchronizers\"\n        FF1[DFF] --&gt; FF2[DFF]\n        FF3[DFF] --&gt; FF4[DFF]\n        FF5[DFF] --&gt; FF6[DFF]\n        FF7[DFF] --&gt; FF8[DFF]\n    end\n\n    subgraph \"Toggle-to-Pulse\"\n        TG1[DFF] --&gt; TG2[DFF]\n        TG3[DFF] --&gt; TG4[DFF]\n        TG2 --&gt; XOR1[XOR with&lt;br/&gt;Previous]\n        TG4 --&gt; XOR2[XOR with&lt;br/&gt;Previous]\n    end\n\n    subgraph \"Reset Synchronizer\"\n        RST1[DFF&lt;br/&gt;Async Reset] --&gt; RST2[DFF&lt;br/&gt;Async Reset]\n    end\n\n    subgraph \"Outputs - HF_CLK Domain\"\n        OUT1[ENSAMP_sync]\n        OUT2[ENLOWPWR_sync]\n        OUT3[AFERSTCH_sync 7:0]\n        OUT4[FIFO_OVERFLOW_sync&lt;br/&gt;1-cycle pulse]\n        OUT5[FIFO_UNDERFLOW_sync&lt;br/&gt;1-cycle pulse]\n        OUT6[NRST_sync]\n        OUT8[CFG_CHNGE_sync]\n        OUT7[PHASE1DIV1_sync 11:0&lt;br/&gt;Direct]\n    end\n\n    subgraph \"Conditional (ENABLE_REGISTER_CRC)\"\n        IN8[CFG_CHNGE] --&gt; FF7\n        FF8 --&gt; OUT8[CFG_CHNGE_sync]\n    end\n\n    IN1 --&gt; FF1\n    IN2 --&gt; FF3\n    IN3 --&gt; FF5\n    IN4 --&gt; TG1\n    IN5 --&gt; TG3\n    IN6 --&gt; RST1\n    IN7 -.-&gt; OUT7\n\n    FF2 --&gt; OUT1\n    FF4 --&gt; OUT2\n    FF6 --&gt; OUT3\n    XOR1 --&gt; OUT4\n    XOR2 --&gt; OUT5\n    RST2 --&gt; OUT6\n\n    CLK[HF_CLK] -.-&gt; FF1\n    CLK -.-&gt; FF2\n    CLK -.-&gt; FF3\n    CLK -.-&gt; FF4\n    CLK -.-&gt; FF5\n    CLK -.-&gt; FF6\n    CLK -.-&gt; FF7\n    CLK -.-&gt; FF8\n    CLK -.-&gt; TG1\n    CLK -.-&gt; TG2\n    CLK -.-&gt; TG3\n    CLK -.-&gt; TG4\n    CLK -.-&gt; RST1\n    CLK -.-&gt; RST2\n\n    style FF1 fill:#ffe,stroke:#333\n    style FF2 fill:#efe,stroke:#333\n    style FF7 fill:#ddd,stroke:#333,stroke-dasharray: 5 5\n    style FF8 fill:#ddd,stroke:#333,stroke-dasharray: 5 5\n    style TG1 fill:#ffe,stroke:#333\n    style TG2 fill:#fee,stroke:#333\n    style XOR1 fill:#fcc,stroke:#333,stroke-width:2px\n    style RST1 fill:#eef,stroke:#333</code></pre>"},{"location":"core_blocks/command_interpreter/","title":"Command Interpreter and SPI core","text":""},{"location":"core_blocks/command_interpreter/#overview","title":"Overview","text":"<p>The Command Interpreter is the control center of the Pepper T4 digital logic. It acts as an SPI slave, decoding host commands and orchestrating data flow between: *   Configuration Registers (write/read configuration) *   FIFO (streaming ADC data to host) *   Status Monitor (reporting system health) *   Temperature Buffer (reading temperature sensor)</p> <p>The module operates entirely in the SCK domain (SPI clock), with careful synchronization of inputs from the HF_CLK domain (Status, ENSAMP, TEMPVAL).</p>"},{"location":"core_blocks/command_interpreter/#spi-protocol","title":"SPI Protocol","text":""},{"location":"core_blocks/command_interpreter/#mode-timing","title":"Mode &amp; Timing","text":"<ul> <li>SPI Mode: Mode 3 (CPOL=1, CPHA=1)<ul> <li>Clock idle state is HIGH</li> <li>Data is captured on the rising edge of SCK</li> <li>Data is shifted out on the falling edge of SCK</li> </ul> </li> <li>Bit Order: MSB first</li> <li>Word Size: 16 bits (8-bit command + 8-bit data)</li> </ul>"},{"location":"core_blocks/command_interpreter/#command-structure","title":"Command Structure","text":"<p>Each SPI transaction begins with an 8-bit command byte from the SPI master:</p> Bits Field Description <code>[7:6]</code> Opcode <code>00</code>=Read Register, <code>01</code>=Read CRC, <code>10</code>=Write Register, <code>11</code>=Read Data <code>[5:0]</code> Blank or Address Blank or register address or stream identifier"},{"location":"core_blocks/command_interpreter/#response-format","title":"Response Format","text":"<p>The module prepends a Status Word to every response:</p> <pre><code>[15:14] = 01 (Status response identifier)\n[13:0]  = 14-bit Status register snapshot\n</code></pre>"},{"location":"core_blocks/command_interpreter/#finite-state-machine","title":"Finite State Machine","text":"<p>The Command Interpreter uses a one-hot encoded 5-state FSM:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; IDLE\n    IDLE --&gt; READ_REG : byte_rcvd &amp; CMD_RDREG\n    IDLE --&gt; WRITE_REG : byte_rcvd &amp; CMD_WRREG\n    IDLE --&gt; READ_DATA : byte_rcvd &amp; CMD_RDDATA &amp; addr==0\n    IDLE --&gt; READ_CRC : byte_rcvd &amp; CMD_RDCRC &amp; addr==0\n\n    READ_REG --&gt; READ_REG : word_rcvd (word 0\u21921)\n    READ_REG --&gt; IDLE : word_rcvd (word 1) | CS high\n\n    WRITE_REG --&gt; IDLE : word_rcvd | CS high\n\n    READ_DATA --&gt; READ_DATA : word_rcvd (streaming)\n    READ_DATA --&gt; IDLE : CS high\n\n    READ_CRC --&gt; IDLE : word_rcvd | CS high\n\n    IDLE --&gt; IDLE : CS high (default reset)</code></pre>"},{"location":"core_blocks/command_interpreter/#state-descriptions","title":"State Descriptions","text":"State Function Exit Condition IDLE Waiting for command byte. Returns Status word on <code>tx_buff</code>. Command opcode decoded READ_REG Two-word sequence: \u2460Status \u2461Register data After 2nd word or CS high WRITE_REG Write data byte to target register (if allowed) After word received or CS high READ_DATA Streaming FIFO readout (8\u00d716-bit words per frame) CS high (manual stop) READ_CRC Return CRC-16-CCITT checksum of last FIFO burst After word or CS high"},{"location":"core_blocks/command_interpreter/#multi-word-transaction-handling","title":"Multi-Word Transaction Handling","text":""},{"location":"core_blocks/command_interpreter/#word-vs-byte-structure","title":"Word vs. Byte Structure","text":"<p>The SPI interface operates on 16-bit words composed of two sequential 8-bit bytes: *   Byte 0: Command or high byte *   Byte 1: Data or low byte</p> <p>The <code>spiCore</code> module provides two pulse signals to the Command Interpreter: *   <code>byte_rcvd</code>: Pulses after each 8-bit byte *   <code>word_rcvd</code>: Pulses after every 2nd byte (16 bits complete)</p>"},{"location":"core_blocks/command_interpreter/#single-word-transactions","title":"Single-Word Transactions","text":"<p>Most commands complete in a single word (16 SCK cycles):</p> <ol> <li>Byte 0 received \u2192 <code>byte_rcvd</code> pulses<ul> <li>Command Interpreter captures opcode and address</li> <li>FSM transitions from <code>IDLE</code> to target state</li> </ul> </li> <li>Byte 1 received \u2192 <code>word_rcvd</code> pulses<ul> <li>For <code>WRITE_REG</code>: Data is written to register</li> <li>For <code>READ_CRC</code>: CRC value is transmitted</li> <li>FSM returns to <code>IDLE</code></li> </ul> </li> </ol>"},{"location":"core_blocks/command_interpreter/#multi-word-transactions","title":"Multi-Word Transactions","text":""},{"location":"core_blocks/command_interpreter/#read_reg-2-word-sequence","title":"READ_REG (2-Word Sequence)","text":"<p>The <code>READ_REG</code> state uses a counter (<code>read_reg_word_count</code>) to track progress:</p> Word Counter MISO Response Action 0 <code>0</code> Status[13:0] + <code>01</code> Command parsed; counter resets to 0 1 <code>1</code> <code>0xC0</code> + Register[7:0] Register data transmitted; return to IDLE <p>Implementation: The counter increments on each <code>word_rcvd</code> while in <code>READ_REG</code> state (line 254-256).</p>"},{"location":"core_blocks/command_interpreter/#read_data-streaming-mode","title":"READ_DATA (Streaming Mode)","text":"<p>For FIFO readout, the transaction continues until the host raises CS:</p> <ol> <li>Word 0: First 16-bit ADC sample (<code>ADC_data[15:0]</code>)</li> <li>Word 1: Second sample (<code>ADC_data[31:16]</code>)</li> <li>...continues...</li> <li>Word 7: Eighth sample (<code>ADC_data[127:112]</code>)</li> <li>Auto-Pop: After word 7, <code>FIFO_POP</code> pulses and a new frame is loaded</li> <li>Word 8+: Streaming continues from the next frame</li> </ol> <p>Word Selection Logic (line 461): <pre><code>tx_buff_reg = ADC_data[word_counter*16 +: 16];\n</code></pre></p> <p>The <code>word_counter</code> (3-bit, 0-7) increments on each <code>word_rcvd</code> and wraps around, triggering a FIFO pop on the transition from 7\u21920.</p>"},{"location":"core_blocks/command_interpreter/#transaction-boundary-reset","title":"Transaction Boundary Reset","text":"<p>Critical: The <code>first_transaction</code> flag (lines 168-174) detects the very first byte after CS assertion. This prevents stale commands from the previous transaction from executing if CS glitches or bounces.</p> <pre><code>always @(posedge SCK or posedge CS) begin\n    if (CS) begin\n        first_transaction &lt;= 1'b1;\n    end else if (byte_rcvd) begin\n        first_transaction &lt;= 1'b0;\n    end\nend\n</code></pre> <p>If <code>first_transaction</code> is high during state execution, the FSM immediately aborts to <code>IDLE</code>.</p>"},{"location":"core_blocks/command_interpreter/#write-protection-permissions","title":"Write Protection &amp; Permissions","text":""},{"location":"core_blocks/command_interpreter/#safe-vs-restricted-registers","title":"Safe vs. Restricted Registers","text":"<p>To prevent glitches in the analog domain, most configuration registers are write-protected when sampling is active (<code>ENSAMP=1</code>).</p> <p>Always writable (exceptions): *   <code>0x12</code> (<code>AFERSTCH</code>): Channel reset control *   <code>0x13</code>: AFE monitor enables *   <code>0x23</code>: Contains <code>ENSAMP</code> bit itself (allows stopping sampling)</p> <p>Protected when <code>ENSAMP=1</code>: *   All other configuration registers (<code>0x00\u20130x22</code>)</p> <p>Always writable (special addresses): *   <code>0x26</code> (<code>STATUS_CLR_LO</code>): Write-1-to-Clear for saturation flags *   <code>0x27</code> (<code>STATUS_CLR_HI</code>): Write-1-to-Clear for upper status bits</p>"},{"location":"core_blocks/command_interpreter/#implementation-detail","title":"Implementation Detail","text":"<p>The write-enable logic (lines 273-286): <pre><code>if (reg_addr_reg &lt;= 6'h23) begin\n    if (!ENSAMP_sync_reg[1] ||\n        (reg_addr_reg == REG_23_SAFE) ||\n        (reg_addr_reg == REG_AFERSTCH) ||\n        (reg_addr_reg == REG_13_SAFE)) begin\n        reg_value_reg &lt;= data_byte;\n        wr_en_reg &lt;= 1'b1;\n    end else begin\n        wr_en_reg &lt;= 1'b0;  // Silently ignore\n    end\nend\n</code></pre></p>"},{"location":"core_blocks/command_interpreter/#clock-domain-crossing-cdc","title":"Clock Domain Crossing (CDC)","text":"<p>The Command Interpreter receives three signals from the HF_CLK domain: 1.  Status[13:0]: System health flags 2.  ENSAMP_sync: Sampling active indicator 3.  TEMPVAL[15:0]: Temperature sensor readout</p> <p>Each is synchronized using 2-stage flip-flop chains (lines 137-151): <pre><code>always @(posedge SCK or negedge NRST) begin\n    status_sync[0] &lt;= status;\n    status_sync[1] &lt;= status_sync[0];  // Use stage [1] for logic\n    // ... similar for TEMPVAL and ENSAMP\nend\n</code></pre></p> <p>This ensures meta-stability is resolved before use in the SCK domain logic.</p>"},{"location":"core_blocks/command_interpreter/#status-clear-w1c-mechanism","title":"Status Clear (W1C) Mechanism","text":"<p>The Command Interpreter implements a Write-1-to-Clear queue with handshake to the HF_CLK domain:</p> <ol> <li>Queue Phase (SCK domain): Writes to <code>0x26</code>/<code>0x27</code> set bits in <code>status_clr_queued_*</code>.</li> <li>Launch Phase: When not in-flight, the queued mask is copied to <code>status_clr_inflight_*</code> and a toggle request is sent.</li> <li>Handshake: The <code>Status_Clear_CDC</code> bridge detects the toggle, pulses the clear in HF_CLK, and toggles back an ack.</li> <li>Consume Phase: The ack toggle is synchronized back to SCK, clearing the in-flight flag.</li> </ol> <p>This allows overlapping clear requests without data loss.</p>"},{"location":"core_blocks/command_interpreter/#example-transaction-write-register","title":"Example Transaction: Write Register","text":"<pre><code>{\n  \"signal\": [\n    {\"name\": \"CS\", \"wave\": \"10..........1\"},\n    {\"name\": \"SCK\", \"wave\": \"0.p.........|\", \"period\": 0.5},\n    {\"name\": \"MOSI\", \"wave\": \"x.===x......\", \"data\": [\"CMD\", \"ADDR\", \"DATA\"]},\n    {\"name\": \"MISO\", \"wave\": \"x....===x...\", \"data\": [\"STAT_HI\", \"STAT_LO\", \"ACK\"]},\n    {},\n    {\"name\": \"byte_rcvd\", \"wave\": \"0..1.0.1.0..\"},\n    {\"name\": \"word_rcvd\", \"wave\": \"0......1.0..\"},\n    {\"name\": \"state\", \"wave\": \"2..3....2...\", \"data\": [\"IDLE\", \"WRITE_REG\", \"IDLE\"]},\n    {\"name\": \"wr_en\", \"wave\": \"0.......1.0.\"}\n  ],\n  \"config\": {\"hscale\": 1.5}\n}</code></pre> <p>Sequence: 1.  Byte 0 (Command): <code>10XXXXXX</code> (WRREG opcode) triggers transition to <code>WRITE_REG</code>. 2.  Byte 1 (Data): Written to target register on <code>word_rcvd</code>. 3.  Response: Status word is returned on MISO during the transaction. 4.  Completion: <code>wr_en</code> pulses for one SCK cycle; state returns to <code>IDLE</code> on CS high.</p>"},{"location":"core_blocks/command_interpreter/#register-address-map-read-access","title":"Register Address Map (Read Access)","text":"Address Name Description <code>0x00\u20130x23</code> Configuration Registers Physical config registers (see Register Map doc) <code>0x24</code> <code>STATUS_LO</code> Status bits [7:0] (Saturation flags) <code>0x25</code> <code>STATUS_HI</code> Status bits [13:8] packed into [5:0] <code>0x2C</code> <code>TEMPVAL_HI</code> Temperature sensor high byte <code>0x2D</code> <code>TEMPVAL_LO</code> Temperature sensor low byte"},{"location":"core_blocks/command_interpreter/#key-design-choices","title":"Key Design Choices","text":"<ol> <li>One-Hot FSM: Simplifies decode logic and improves timing in ASIC.</li> <li>Always-Valid <code>tx_buff</code>: The transmit buffer is combinationally generated, ensuring data is ready before the SPI core shifts it out.</li> <li>First Transaction Detection: Uses an asynchronous set flip-flop (line 168) to detect the very first byte after CS assertion, preventing stale commands from executing.</li> <li>Modular CRC: The CRC-16-CCITT calculation is self-contained (lines 375-411) and can be easily removed if area is critical.</li> </ol>"},{"location":"core_blocks/fifo/","title":"FIFO","text":""},{"location":"core_blocks/fifo/#overview","title":"Overview","text":"<p>The Pepper T4 FIFO is a frame-based asynchronous FIFO that buffers multi-channel ADC data between the sampling domain (<code>SAMPLE_CLK</code>) and the SPI readout domain (<code>SCK</code>). Unlike a conventional word-level FIFO, each entry is a 128-bit frame containing 8 \u00d7 16-bit ADC samples (one per channel).</p>"},{"location":"core_blocks/fifo/#architecture","title":"Architecture","text":""},{"location":"core_blocks/fifo/#clock-domains","title":"Clock Domains","text":"<ul> <li>Write Domain (<code>SAMPLE_CLK</code>): ADC results are written word-by-word using one-hot <code>ATMCHSEL</code>, then the frame pointer advances on <code>LASTWORD</code>.</li> <li>Read Domain (<code>SCK</code>): The Command Interpreter issues <code>FIFO_POP</code> to read complete 128-bit frames.</li> </ul>"},{"location":"core_blocks/fifo/#memory-structure","title":"Memory Structure","text":"<pre><code>Parameter: FRAME_DEPTH (default 4, must be power of 2)\n\nEach frame slot:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502CH0[15:0]\u2502CH1[15:0]\u2502CH2[15:0]\u2502...\u2502CH7[15:0]\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  bits 15:0   31:16      47:32          127:112\n</code></pre>"},{"location":"core_blocks/fifo/#gray-code-pointer-synchronization","title":"Gray Code Pointer Synchronization","text":"<pre><code>flowchart LR\n    subgraph Write Domain - SAMPLE_CLK\n        WP[write_ptr binary] --&gt; WPG[write_ptr_gray]\n        RPG_S1[read_ptr_gray_sync1] --&gt; RPS[read_ptr_sync]\n        RPS --&gt; RPSB[read_ptr_sync_bin]\n    end\n\n    subgraph Read Domain - SCK\n        RP[read_ptr binary] --&gt; RPG[read_ptr_gray]\n        WPG_S1[write_ptr_gray_sync1] --&gt; WPS[write_ptr_sync]\n        WPS --&gt; WPSB[write_ptr_sync_bin]\n    end\n\n    RPG -.-&gt;|2-stage sync| RPG_S1\n    WPG -.-&gt;|2-stage sync| WPG_S1</code></pre> <p>Pointers use an extra MSB beyond the address width. This allows distinguishing \"full\" (pointers differ only in MSB) from \"empty\" (pointers equal). Gray coding ensures only one bit changes per increment, preventing meta-stability glitches during CDC.</p> <p>Conversion functions (lines 62-78): <pre><code>bin_to_gray = bin ^ (bin &gt;&gt; 1);\n// Gray-to-binary: XOR cascade from MSB down\n</code></pre></p>"},{"location":"core_blocks/fifo/#write-behavior-sample_clk-domain","title":"Write Behavior (SAMPLE_CLK Domain)","text":""},{"location":"core_blocks/fifo/#word-level-writes","title":"Word-Level Writes","text":"<p>ADC results are written to specific 16-bit slots within the current frame using the one-hot <code>ATMCHSEL</code> signal:</p> <pre><code>case (1'b1)\n    ATMCHSEL[0]: mem[write_ptr][15:0]    &lt;= RESULT;\n    ATMCHSEL[1]: mem[write_ptr][31:16]   &lt;= RESULT;\n    // ... up to ATMCHSEL[7]\nendcase\n</code></pre> <p>This allows sparse writes: only enabled channels update their slots. Disabled channels read as zero because the frame is pre-cleared.</p>"},{"location":"core_blocks/fifo/#frame-advance","title":"Frame Advance","text":"<p>On <code>LASTWORD</code>, the write pointer advances and the next frame slot is pre-cleared to zero:</p> <pre><code>if (LASTWORD) begin\n    mem[write_ptr_next] &lt;= 128'h0;  // Pre-clear next slot\n    write_ptr &lt;= write_ptr + 1;\n    write_ptr_gray &lt;= bin_to_gray(write_ptr + 1);\nend\n</code></pre>"},{"location":"core_blocks/fifo/#frame-cleanup-after-read","title":"Frame Cleanup After Read","text":"<p>When a <code>frame_pop_edge</code> is detected (synchronized from SCK domain), the write domain zeros out the previously-read frame slot to prevent stale data leakage:</p> <pre><code>if (frame_pop_edge)\n    mem[read_ptr_sync_prev_idx] &lt;= 128'h0;\n</code></pre>"},{"location":"core_blocks/fifo/#read-behavior-sck-domain","title":"Read Behavior (SCK Domain)","text":""},{"location":"core_blocks/fifo/#look-ahead-read-interface","title":"Look-Ahead Read Interface","text":"<p>The FIFO implements Look-Ahead Read behavior. The data at <code>read_ptr</code> is continuously driven to <code>ADC_data</code> whenever frames are available.</p> <ul> <li>Before POP: <code>ADC_data</code> contains the current valid frame (or zero if empty).</li> <li>FIFO_POP Pulse: Advances the read pointer to the next frame.</li> <li>Latency: Data is valid immediately upon <code>DATA_RDY</code> assertion (subject to synchronization latency).</li> </ul> <p>Integration Simplified</p> <p>Unlike previous versions, there is no dummy pop required. The first frame of data is valid and present on <code>ADC_data</code> as soon as the FIFO is not empty.</p>"},{"location":"core_blocks/fifo/#read-logic-lines-240-270","title":"Read Logic (lines 240-270)","text":"<pre><code>// Look-ahead: Output valid data if available\nif (frames_available)\n    ADC_data &lt;= mem[read_ptr[ADDR_WIDTH-1:0]];\nelse\n    ADC_data &lt;= 128'h0;\n\n// POP only advances the pointer\nif (FIFO_POP &amp;&amp; frames_available) begin\n    read_ptr      &lt;= read_ptr + 1'b1;\n    read_ptr_gray &lt;= bin_to_gray(read_ptr + 1'b1);\nend\n</code></pre>"},{"location":"core_blocks/fifo/#flags-status","title":"Flags &amp; Status","text":""},{"location":"core_blocks/fifo/#data_rdy-watermark","title":"DATA_RDY (Watermark)","text":"<p><pre><code>DATA_RDY = (frame_count &gt;= FIFOWATERMARK) &amp;&amp; ENSAMP_sync;\n</code></pre> *   Asserted when the number of buffered frames meets or exceeds the configured watermark threshold. *   Gated by <code>ENSAMP_sync</code>: DATA_RDY is forced low when sampling is disabled.</p>"},{"location":"core_blocks/fifo/#frame-count","title":"Frame Count","text":"<p><pre><code>frame_count = write_ptr - read_ptr_sync_bin;\n</code></pre> Computed in the write domain using the synchronized read pointer. This is a conservative estimate (may lag by up to 2 SAMPLE_CLK cycles due to synchronization latency).</p>"},{"location":"core_blocks/fifo/#overflow","title":"Overflow","text":"Condition <code>frame_count == FRAME_DEPTH</code> when <code>LASTWORD</code> asserts Mechanism Toggle <code>fifo_overflow_evt_tgl</code> Meaning A new frame was committed but the FIFO was already full; the oldest unread frame is silently overwritten"},{"location":"core_blocks/fifo/#underflow","title":"Underflow","text":"Condition <code>FIFO_POP</code> asserted when <code>!frames_available</code> while <code>ENSAMP_sync</code> is high Mechanism Toggle <code>fifo_underflow_evt_tgl</code> Meaning Host attempted to read but no data was available; <code>ADC_data</code> returns zeros <p>Toggle-Based Event Signaling</p> <p>Overflow and underflow are signaled as toggle events, not level flags. The <code>CDC_sync</code> module detects edges on these toggles to generate single-cycle pulses in the <code>HF_CLK</code> domain for the Status Monitor. This avoids the need for handshake protocols and is robust to clock ratio variations.</p>"},{"location":"core_blocks/fifo/#reset-disable-behavior","title":"Reset &amp; Disable Behavior","text":""},{"location":"core_blocks/fifo/#global-reset-nrst_sync","title":"Global Reset (<code>NRST_sync</code>)","text":"<p>Clears all pointers, memory, and event toggles in both domains.</p>"},{"location":"core_blocks/fifo/#sampling-disable-ensamp_sync-low","title":"Sampling Disable (<code>ENSAMP_sync</code> \u2192 low)","text":"<p>Write domain (synchronous to <code>SAMPLE_CLK</code>): *   Write pointer reset to zero *   All memory cleared</p> <p>Read domain (asynchronous assert, synchronous deassert to <code>SCK</code>): *   Uses a dedicated reset synchronizer (<code>ensamp_rst_ff</code>) to safely bring the read domain to a clean state:     <pre><code>// Assert async on ENSAMP_sync low; release sync after 2 SCK cycles\nalways @(posedge SCK or negedge NRST_sync or negedge ENSAMP_sync) begin\n    if (!NRST_sync || !ENSAMP_sync)\n        ensamp_rst_ff &lt;= 2'b00;\n    else\n        ensamp_rst_ff &lt;= {ensamp_rst_ff[0], 1'b1};\nend\nassign ensamp_rstn_sck = ensamp_rst_ff[1];\n</code></pre> *   Read pointer and <code>ADC_data</code> cleared to zero *   Underflow toggle is preserved (not reset) to avoid false CDC edges</p> <p>Procedural Constraint</p> <p>After disabling sampling (<code>ENSAMP=0</code>), the MCU must end the current SPI transaction before issuing any RDDATA commands. FIFO reads while disabled return undefined/zero data.</p>"},{"location":"core_blocks/fifo/#timing-reference","title":"Timing Reference","text":"<pre><code>{\n  \"signal\": [\n    {\"name\": \"SAMPLE_CLK\", \"wave\": \"p............\"},\n    {\"name\": \"DONE\",       \"wave\": \"010101010....\"},\n    {\"name\": \"ATMCHSEL\",   \"wave\": \"3.4.5.6.x....\", \"data\": [\"CH0\",\"CH1\",\"CH2\",\"CH3\"]},\n    {\"name\": \"LASTWORD\",   \"wave\": \"0......10....\"},\n    {\"name\": \"write_ptr\",  \"wave\": \"2......2.....\", \"data\": [\"N\", \"N+1\"]},\n    {},\n    {\"name\": \"SCK\",         \"wave\": \"p............\"},\n    {\"name\": \"DATA_RDY\",    \"wave\": \"0.......1....\"},\n    {\"name\": \"FIFO_POP\",    \"wave\": \"0........10..\"},\n    {\"name\": \"ADC_data\",    \"wave\": \"x........2...\", \"data\": [\"Frame N\"]},\n    {\"name\": \"read_ptr\",    \"wave\": \"2........2...\", \"data\": [\"N\", \"N+1\"]}\n  ],\n  \"config\": {\"hscale\": 1.2}\n}</code></pre>"},{"location":"functional/status_logic/","title":"Status Generation and Clearing Logic","text":""},{"location":"functional/status_logic/#overview","title":"Overview","text":"<p>The status monitoring system in the Pepper T4 design tracks various error and state conditions across multiple clock domains. Status bits are generated in the high-frequency clock domain (<code>HF_CLK</code>) and can be cleared via commands from the SPI clock domain (<code>SCK</code>). This document describes the lifecycle of status bits, the clearing mechanism, and the gating behavior.</p>"},{"location":"functional/status_logic/#the-cycle-of-a-status-bit","title":"The Cycle of a Status Bit","text":"<p>This section describes the process that occurs for each status bit from event detection through synchronization to final registration:</p>"},{"location":"functional/status_logic/#1-event-detection-source-domain","title":"1. Event Detection (Source Domain)","text":"<p>Status events originate from various sources in the design: - FIFO Overflow/Underflow: Pulses from the FIFO module (already synchronized to <code>HF_CLK</code>) - ADC Overflow: Pulse from the ADC indicating overflow condition - Saturation Detection: 8-bit vector indicating which channels detected saturation - Analog Frontend Reset: 8-bit vector indicating AFE reset events - Configuration Change: Detected by comparing current <code>CRCCFG</code> with previous value</p>"},{"location":"functional/status_logic/#2-synchronization-to-hf_clk","title":"2. Synchronization to HF_CLK","text":"<p>Most status sources are already synchronized to <code>HF_CLK</code> before reaching the <code>Status_Monitor</code> module: - <code>FIFO_OVERFLOW_sync</code> and <code>FIFO_UNDERFLOW_sync</code> are pre-synchronized - <code>AFERSTCH_sync</code> and <code>SATDETECT_sync</code> are pre-synchronized - <code>ADCOVERFLOW</code> is generated in the <code>HF_CLK</code> domain - <code>CRCCFG</code> change detection happens directly in <code>HF_CLK</code> domain</p>"},{"location":"functional/status_logic/#3-sticky-bits-memory-behavior","title":"3. Sticky Bits (Memory Behavior)","text":"<p>The <code>Status_Monitor</code> module implements sticky status bits using synchronous registers:</p> <pre><code>// Example: FIFO Overflow status bit\nif (FIFO_OVERFLOW_sync) begin\n    fifo_ovf_flag &lt;= 1'b1;  // Set on event\nend\n</code></pre> <p>Key characteristics: - Synchronous Set: Status bits are set on the rising edge of <code>HF_CLK</code> when the event signal is high - Sticky: Once set, the bit remains high until explicitly cleared by software - Priority: If an event occurs in the same cycle as a clear command, the set operation takes priority (event is not lost)</p>"},{"location":"functional/status_logic/#4-registration-and-output","title":"4. Registration and Output","text":"<p>All status bits are registered in the <code>HF_CLK</code> domain and assembled into a 14-bit status word:</p> Bit Name Description 13 ENSAMP Enable Sampling state (not sticky) 12 CFGCHNG Configuration changed 11 ANALOG_RESET Analog frontend reset detected 10 FIFO_UDF FIFO underflow 9 FIFO_OVF FIFO overflow 8 ADC_OVF ADC overflow 7:0 SAT[7:0] Saturation detection per channel"},{"location":"functional/status_logic/#clearing-mechanism","title":"Clearing Mechanism","text":""},{"location":"functional/status_logic/#write-1-to-clear-w1c-protocol","title":"Write-1-to-Clear (W1C) Protocol","text":"<p>Status bits use the W1C (Write-1-to-Clear) protocol: - Software writes a <code>1</code> to a status bit position to clear it - Writing <code>0</code> has no effect (preserves current state) - Multiple bits can be cleared simultaneously by writing a mask with multiple <code>1</code>s</p>"},{"location":"functional/status_logic/#cross-domain-clear-propagation","title":"Cross-Domain Clear Propagation","text":"<p>Since status bits live in the <code>HF_CLK</code> domain but are cleared from the <code>SCK</code> domain, the <code>Status_Clear_CDC</code> module handles the clock domain crossing:</p>"},{"location":"functional/status_logic/#step-1-toggle-request-sck-domain","title":"Step 1: Toggle Request (SCK Domain)","text":"<p>The command interpreter in the <code>SCK</code> domain initiates a clear by: 1. Setting up the clear mask (<code>status_clr_lo_sck[7:0]</code> and <code>status_clr_hi_sck[5:0]</code>) 2. Toggling the request signal (<code>status_clr_req_tgl_sck</code>) 3. Waiting for acknowledgment toggle</p>"},{"location":"functional/status_logic/#step-2-synchronization-cdc-module","title":"Step 2: Synchronization (CDC Module)","text":"<p>The <code>Status_Clear_CDC</code> module: 1. Synchronizes the toggle request using a 2-FF synchronizer chain 2. Synchronizes the mask bits using separate 2-FF chains (mask is held stable during the handshake) 3. Detects the toggle edge by comparing current and previous synchronized toggle values 4. Delays the clear pulse by 2 <code>HF_CLK</code> cycles to ensure mask bits are fully synchronized and stable</p> <pre><code>// Edge detection\nassign req_edge = (req_ff[1] ^ req_prev);\n\n// Delayed pulse generation\nif (req_edge) begin\n    pending &lt;= 1'b1;\n    pending_cnt &lt;= 2'b00;\nend else if (pending) begin\n    pending_cnt &lt;= pending_cnt + 1'b1;\n    if (pending_cnt == 2'b10) begin\n        pulse_reg &lt;= 1'b1;           // Fire clear pulse\n        ack_tgl_reg &lt;= ~ack_tgl_reg; // Toggle acknowledgment\n        pending &lt;= 1'b0;\n    end\nend\n</code></pre>"},{"location":"functional/status_logic/#step-3-clear-execution-status-monitor","title":"Step 3: Clear Execution (Status Monitor)","text":"<p>When <code>status_clr_pulse</code> is asserted, the <code>Status_Monitor</code> clears bits according to the mask:</p> <pre><code>if (status_clr_pulse) begin\n    if (status_clr_mask[12]) cfgchng_flag &lt;= 1'b0;\n    if (status_clr_mask[11]) analog_reset_flag &lt;= 1'b0;\n    if (status_clr_mask[10]) fifo_udf_flag &lt;= 1'b0;\n    if (status_clr_mask[9])  fifo_ovf_flag &lt;= 1'b0;\n    if (status_clr_mask[8])  adc_ovf_flag &lt;= 1'b0;\n    for (i = 0; i &lt; 8; i = i + 1) begin\n        if (status_clr_mask[i]) sat_flags[i] &lt;= 1'b0;\n    end\nend\n</code></pre>"},{"location":"functional/status_logic/#step-4-acknowledgment-back-to-sck-domain","title":"Step 4: Acknowledgment (Back to SCK Domain)","text":"<p>The acknowledgment toggle (<code>status_clr_ack_tgl_hf</code>) is synchronized back to the <code>SCK</code> domain, allowing the command interpreter to proceed with the next operation.</p>"},{"location":"functional/status_logic/#gating-with-ensamp","title":"Gating with ENSAMP","text":""},{"location":"functional/status_logic/#ensamp-behavior","title":"ENSAMP Behavior","text":"<p>The <code>ENSAMP</code> (Enable Sampling) signal has unique characteristics compared to other status bits:</p> <ol> <li> <p>Not Sticky: <code>ENSAMP</code> directly reflects the synchronized state of the sampling enable signal    <pre><code>ensamp_flag &lt;= ENSAMP_sync;  // Updated every cycle\n</code></pre></p> </li> <li> <p>Not Clearable: The <code>ENSAMP</code> bit (bit 13) is not included in the clearable status bits. It cannot be cleared via W1C.</p> </li> <li> <p>State Indicator: It serves as a real-time indicator of whether sampling is currently enabled, not as an error flag.</p> </li> </ol>"},{"location":"functional/status_logic/#effect-on-status-generation","title":"Effect on Status Generation","text":"<p>Important: <code>ENSAMP</code> does NOT gate the generation of other status bits in the <code>Status_Monitor</code> module.</p> <ul> <li>Status events (FIFO overflow, ADC overflow, saturation, etc.) can be set even when sampling is disabled (<code>ENSAMP_sync = 0</code>)</li> <li>This design choice ensures that error conditions are always captured, regardless of sampling state</li> <li>The gating of actual data sampling happens elsewhere in the design (e.g., in the ADC interface or FIFO write logic)</li> </ul> <p>This behavior is intentional and allows the system to detect and report error conditions that may occur during startup, shutdown, or configuration changes when sampling is temporarily disabled.</p>"},{"location":"functional/status_logic/#status-lifecycle-diagram","title":"Status Lifecycle Diagram","text":"<p>The following Mermaid flowchart visualizes the complete loop from event detection through clearing:</p> <pre><code>flowchart TD\n    Start([Event Occurs]) --&gt; Sync{Already in&lt;br/&gt;HF_CLK?}\n    Sync --&gt;|Yes| Stick[Set Status Bit&lt;br/&gt;Sticky Register]\n    Sync --&gt;|No| CDC[CDC Synchronizer] --&gt; Stick\n\n    Stick --&gt; Status[Status Register&lt;br/&gt;14-bit Word]\n    Status --&gt; Bus[Read by MCU&lt;br/&gt;via SPI Bus]\n\n    Bus --&gt; Decision{Error&lt;br/&gt;Handled?}\n    Decision --&gt;|No| Bus\n    Decision --&gt;|Yes| Write[MCU Writes W1C&lt;br/&gt;Clear Mask]\n\n    Write --&gt; TogReq[Toggle Request&lt;br/&gt;SCK Domain]\n    TogReq --&gt; SyncReq[Sync Toggle to&lt;br/&gt;HF_CLK Domain]\n    SyncReq --&gt; SyncMask[Sync Mask Bits&lt;br/&gt;2-FF Chain]\n\n    SyncMask --&gt; Delay[Delay 2 Cycles&lt;br/&gt;Ensure Mask Stable]\n    Delay --&gt; Pulse[Assert Clear Pulse&lt;br/&gt;+ Mask]\n\n    Pulse --&gt; Clear{Mask Bit&lt;br/&gt;Set?}\n    Clear --&gt;|Yes| Reset[Clear Status Bit&lt;br/&gt;flag &lt;= 0]\n    Clear --&gt;|No| Keep[Keep Status Bit]\n\n    Reset --&gt; Ack[Toggle Ack to&lt;br/&gt;SCK Domain]\n    Keep --&gt; Ack\n    Ack --&gt; Done([Clear Complete])\n\n    Stick -.-&gt;|New Event| Stick\n\n    style Start fill:#e1f5e1\n    style Done fill:#e1f5e1\n    style Stick fill:#fff4e1\n    style Clear fill:#ffe1e1\n    style Reset fill:#e1e5ff</code></pre>"},{"location":"functional/status_logic/#diagram-legend","title":"Diagram Legend","text":"<ul> <li>Green: Start/End points</li> <li>Yellow: Latching/Storage operations</li> <li>Red: Decision points</li> <li>Blue: Clear operations</li> <li>Dashed line: Concurrent event handling (new events can occur while status is latched)</li> </ul>"},{"location":"functional/status_logic/#key-design-considerations","title":"Key Design Considerations","text":""},{"location":"functional/status_logic/#1-metastability-protection","title":"1. Metastability Protection","text":"<ul> <li>All clock domain crossings use proper 2-FF synchronizer chains</li> <li>Toggle-based handshaking ensures reliable cross-domain communication</li> <li>Mask bits are held stable during the handshake to prevent metastability</li> </ul>"},{"location":"functional/status_logic/#2-race-condition-handling","title":"2. Race Condition Handling","text":"<ul> <li>Clear logic executes before set logic in the same <code>always</code> block</li> <li>If an event occurs in the same cycle as a clear, the set takes priority</li> <li>This ensures no events are lost during clearing</li> </ul>"},{"location":"functional/status_logic/#3-timing-constraints","title":"3. Timing Constraints","text":"<ul> <li>The 2-cycle delay in <code>Status_Clear_CDC</code> ensures synchronized mask bits are stable before use</li> <li>Toggle-based handshaking is frequency-independent (works across arbitrary clock ratios)</li> </ul>"},{"location":"functional/status_logic/#4-software-considerations","title":"4. Software Considerations","text":"<ul> <li>Software must read status, handle the condition, then write W1C to clear</li> <li>Multiple status bits can be cleared in a single write operation</li> <li><code>ENSAMP</code> bit cannot be cleared (it's a state indicator, not an error flag)</li> </ul>"},{"location":"functional/status_logic/#related-modules","title":"Related Modules","text":"<ul> <li><code>Status_Monitor.v</code> - Main status bit registration and assembly</li> <li><code>Status_Clear_CDC.v</code> - Clock domain crossing for clear commands</li> <li><code>Command_Interpreter.v</code> - Initiates clear requests from SPI domain</li> </ul>"},{"location":"peripherals/atm_control/","title":"ATM Control Module","text":""},{"location":"peripherals/atm_control/#overview","title":"Overview","text":"<p>The <code>ATM_Control</code> module is a predictive channel sequencer responsible for cycling through enabled analog channels for the ADC.</p> <p>Unlike simple sequencers that wait for an ADC \"Done\" signal to switch channels, the ATM Control block maintains its own internal counter to predict exactly when the next conversion will begin. It switches the analog mux one cycle before the conversion start, ensuring the analog signal is stable during the acquisition phase.</p> <p>It also provides pipelined signals (<code>ATMCHSEL_DATA</code>, <code>LASTWORD</code>) that are aligned with the ADC's data output, facilitating correct data tagging in the FIFO.</p>"},{"location":"peripherals/atm_control/#control-sequence","title":"Control Sequence","text":""},{"location":"peripherals/atm_control/#1-triggering","title":"1. Triggering","text":"<p>The sequence is enabled by the <code>ENSAMP_sync</code> signal. - Enable (<code>ENSAMP_sync = 1</code>): The sequence begins immediately. The first channel selected is the lowest enabled index (e.g., Channel 0). - Disable (<code>ENSAMP_sync = 0</code>): The internal counters and outputs are reset to 0.</p>"},{"location":"peripherals/atm_control/#2-state-machine","title":"2. State Machine","text":"<p>The module implements a circular state machine that iterates through the enabled channels specified in <code>CHEN_sync</code>:</p> <ol> <li>Startup: When enabled, the mux (<code>ATMCHSEL</code>) is set to the first enabled channel.</li> <li>Conversion Timing: An internal counter (<code>cycle_count</code>) tracks the duration of the current conversion based on the Oversampling Ratio (OSR).</li> <li>Predictive Switch: At the terminal count (end of the current conversion window), the logic:<ul> <li>Calculates the next enabled channel in a circular fashion (wrapping from Ch7 to Ch0).</li> <li>Updates <code>ATMCHSEL</code> to this new channel immediately.</li> <li>This ensures the mux is switched and settling while the ADC is finishing the previous sample and preparing to acquire the next.</li> </ul> </li> <li>Data Alignment:<ul> <li><code>ATMCHSEL_DATA</code> effectively delays <code>ATMCHSEL</code> by one cycle. This matches the ADC's internal pipeline (Sample -&gt; Done aligned).</li> <li><code>LASTWORD</code> is asserted when the data corresponding to the highest index channel is valid.</li> </ul> </li> </ol>"},{"location":"peripherals/atm_control/#3-conversion-lengths","title":"3. Conversion Lengths","text":"<p>The duration of each step depends on the <code>OSR_sync</code> setting:</p> Mode OSR Formula Cycles Description SAR 0 <code>1</code> 1 Single-cycle sampling (fastest) NS N &gt; 0 <code>4*N + 2</code> 6, 10, ... Noise-shaping oversampling"},{"location":"peripherals/atm_control/#timing-diagram","title":"Timing Diagram","text":"<p>The following WaveDrom diagram illustrates a sequence with OSR=0 (SAR Mode, 1 cycle/conv) enabling Ch0, Ch1, and Ch2.</p> <pre><code>{signal: [\n  {name: 'CLK',       wave: 'p........'},\n  {name: 'ENSAMP',    wave: '01.......'},\n  {name: 'CHEN',      wave: 'x3.......', data: ['0,1,2']},\n  {name: 'Counter',   wave: '=.=======', data: ['0','0','0','0','0','0','0','0']},\n  {name: 'ATMCHSEL',  wave: '0345345..', data: ['CH0', 'CH1', 'CH2', 'CH0', 'CH1', 'CH2']},\n  {name: 'ATMCHSEL_DATA', wave: '0.34534..', data: ['CH0', 'CH1', 'CH2', 'CH0', 'CH1']},\n  {name: 'LASTWORD',  wave: '0...1.1..'}\n]}\n</code></pre>"},{"location":"peripherals/atm_control/#key-timing-points","title":"Key Timing Points:","text":"<ul> <li>ATMCHSEL: Updates at the rising edge of the cycle where the conversion starts.</li> <li>ATMCHSEL_DATA: Appears 1 cycle later, perfectly aligned with when the ADC would assert <code>ADC_DONE</code> and valid data.</li> </ul>"},{"location":"peripherals/atm_control/#configuration-registers","title":"Configuration Registers","text":"<p>The module behavior is controlled by the following inputs (conceptually registers from the config block):</p> Signal Width Description <code>ENSAMP_sync</code> 1 Enable Sampling. Master switch for the sequencer. <code>CHEN_sync</code> 8 Channel Enable Mask. Bit N enables Channel N. The sequencer skips disabled channels. <code>OSR_sync</code> 4 Oversampling Ratio. Defines the conversion length.\u2022 <code>0</code>: SAR Mode (1 cycle)\u2022 <code>1-15</code>: NS Mode (<code>4*OSR + 2</code> cycles) <code>ENLOWPWR_sync</code> 1 Low Power Mode. When set, forces the physical mux output <code>CHSEL</code> to follow <code>ATMCHSEL</code>. When clear, <code>CHSEL</code> is static? (Note: Code <code>assign CHSEL = ENLOWPWR ? atmchsel : CHEN</code> implies static <code>CHEN</code> drive if not low power.)."},{"location":"peripherals/atm_control/#output-signals","title":"Output Signals","text":"Signal Description <code>ATMCHSEL[7:0]</code> The Look-Ahead mux selection. Connects to the analog mux hardware. Updates before data is ready. <code>ATMCHSEL_DATA[7:0]</code> The Data-Aligned mux ID. Connects to the FIFO to tag the current data word. <code>LASTWORD</code> Frame Sycronization. High when <code>ATMCHSEL_DATA</code> corresponds to the last enabled channel in the sequence. Used by FIFO to packetize data."},{"location":"peripherals/configuration_registers/","title":"Configuration Registers","text":"<p>The <code>Configuration_Registers</code> module implements a bank of 36 8-bit registers, providing a total of 288 bits of configuration data to various blocks in the Pepper T4 digital system. These registers are primarily written via the SPI interface during the configuration phase.</p>"},{"location":"peripherals/configuration_registers/#overview","title":"Overview","text":"<ul> <li>Address Range: <code>0x00</code> to <code>0x23</code> (36 registers).</li> <li>Reset State: All registers are reset to <code>0x00</code> when <code>NRST</code> is asserted (active low).</li> <li>Write Mechanism: Writes occur on the rising edge of <code>SCK</code> when <code>wr_en</code> is high and the address is within the valid range (&lt; 36).</li> <li>Output: The concatenated 512-bit <code>cfg_data</code> bus provides register values to the system. Bits <code>[287:0]</code> contain the register data, while <code>[511:288]</code> are tied low.</li> </ul>"},{"location":"peripherals/configuration_registers/#register-map","title":"Register Map","text":"Address Register Name Type Default Description <code>0x00</code> CREF Control R/W <code>0x00</code> Voltage regulator controls (AFE, ADC, DIG). <code>0x01</code> CREF Trim 1 R/W <code>0x00</code> Resistor trimming for Bandgap and AFE regulators. <code>0x02</code> CREF Trim 2 R/W <code>0x00</code> Resistor trimming for ADC and DIG regulators. <code>0x03</code> SPARECREF R/W <code>0x00</code> Spare 8-bit register for CREF. <code>0x04</code> BIAS Control R/W <code>0x00</code> Bias section, Temp sensor, and ITEST enablement. <code>0x05</code> BIAS Trim / LNA0 R/W <code>0x00</code> Bias trim and CH0 AFELNA current settings. <code>0x06</code> LNA 1/2 Trim R/W <code>0x00</code> CH1 and CH2 AFELNA current settings. <code>0x07</code> LNA 3/4 Trim R/W <code>0x00</code> CH3 and CH4 AFELNA current settings. <code>0x08</code> LNA 5/6 Trim R/W <code>0x00</code> CH5 and CH6 AFELNA current settings. <code>0x09</code> LNA 7 / LPF 0 Trim R/W <code>0x00</code> CH7 LNA and CH0 LPF current settings. <code>0x0A</code> LPF 1/2 Trim R/W <code>0x00</code> CH1 and CH2 AFELPF current settings. <code>0x0B</code> LPF 3/4 Trim R/W <code>0x00</code> CH3 and CH4 AFELPF current settings. <code>0x0C</code> LPF 5/6 Trim R/W <code>0x00</code> CH5 and CH6 AFELPF current settings. <code>0x0D</code> LPF 7 / BUF Trim R/W <code>0x00</code> CH7 LPF and AFEBUF current settings. <code>0x0E</code> ADC Trim R/W <code>0x00</code> IT setting for ADC. <code>0x0F</code> SPAREBIAS1 R/W <code>0x00</code> Spare 8-bit register for BIAS. <code>0x10</code> SPAREBIAS2 R/W <code>0x00</code> Spare 8-bit register for BIAS. <code>0x11</code> AFE Control 1 R/W <code>0x00</code> Enablement for LNA, LPF, BUF, and Sensing/Ref modes. <code>0x12</code> AFE Reset R/W <code>0x00</code> Reset (active high) for selected AFE channels. <code>0x13</code> AFE Control 2 R/W <code>0x00</code> AFEBUF reset, gain, and monitoring controls. <code>0x14</code> LPF Bandwidth R/W <code>0x00</code> AFELPF cut-off frequency tuning. <code>0x15</code> Low Power Mode R/W <code>0x00</code> Enable sequential channel switching. <code>0x16</code> Channel Enable R/W <code>0x00</code> Selection of channels to be sampled. <code>0x17</code> SPAREAFE R/W <code>0x00</code> Spare 8-bit register for AFE. <code>0x18</code> ATM Control 1 R/W <code>0x00</code> Analog Test Mux Enablement (IN/OUT/LNA/LPF/BUF). <code>0x19</code> ATM mode R/W <code>0x00</code> Operation mode of the ATM. <code>0x1A</code> SPAREATM R/W <code>0x00</code> Spare 8-bit register for ATM. <code>0x1B</code> ADC Control 1 R/W <code>0x00</code> ADC Over-sampling ratio, DWA, Chopper, and Error Shaping. <code>0x1C</code> ADC Control 2 R/W <code>0x00</code> ADC Gain, Ext Clock, and Override controls. <code>0x1D</code> ADC / Test Control R/W <code>0x00</code> Digital/Analog test signal selection. <code>0x1E</code> SPAREADC1 R/W <code>0x00</code> Spare 8-bit register for ADC. <code>0x1F</code> SPAREADC2 R/W <code>0x00</code> Spare 8-bit register for ADC. <code>0x20</code> Digital Phase 1 Div R/W <code>0x00</code> Phase divider settings for digital control. <code>0x21</code> Digital Phase 1 Cnt R/W <code>0x00</code> Phase count and secondary divider settings. <code>0x22</code> Digital Phase 2 Cnt R/W <code>0x00</code> Phase 2 count settings. <code>0x23</code> Global Control R/W <code>0x00</code> Sample Enable, Force Write, and FIFO Watermarks."},{"location":"peripherals/configuration_registers/#bit-fields","title":"Bit Fields","text":""},{"location":"peripherals/configuration_registers/#0x00-cref-control","title":"<code>0x00</code> - CREF Control","text":"Bit Name Default Description <code>0</code> <code>ENREGAFE</code> <code>0</code> Enable AFE Voltage Regulator. <code>1</code> <code>ENREGADC</code> <code>0</code> Enable ADC Voltage Regulator. <code>2</code> <code>PDREGDIG</code> <code>0</code> Power down DIG Voltage Regulator (0=ON, 1=OFF). <code>7:3</code> <code>RESERVED</code> <code>0</code>"},{"location":"peripherals/configuration_registers/#0x11-afe-control-1","title":"<code>0x11</code> - AFE Control 1","text":"Bit Name Default Description <code>0</code> <code>ENAFELNA</code> <code>0</code> Enable AFELNA. <code>1</code> <code>ENAFELPF</code> <code>0</code> Enable AFELPF. <code>2</code> <code>ENAFEBUF</code> <code>0</code> Enable AFEBUF. <code>3</code> <code>SENSEMODE</code> <code>0</code> Sensing mode: 0 = Monopolar, 1 = Bipolar. <code>4</code> <code>ENREFBUF</code> <code>0</code> Enable external REF buffer (0 = Bypass). <code>5</code> <code>REFMODE</code> <code>0</code> Electrode reference: 0 = External, 1 = Internal. <code>6</code> <code>AFELPFBYP</code> <code>0</code> Bypass LPF (LNA direct to BUF). <code>7</code> <code>RESERVED</code> <code>0</code>"},{"location":"peripherals/configuration_registers/#0x13-afe-control-2","title":"<code>0x13</code> - AFE Control 2","text":"Bit Name Default Description <code>0</code> <code>AFEBUFRST</code> <code>0</code> Reset AFEBUF (Active High). <code>2:1</code> <code>AFEBUFGT&lt;1:0&gt;</code> <code>00</code> Set AFEBUF gain. <code>3</code> <code>ENMONTSENSE</code> <code>0</code> Enable Monitoring Temperature Sensor. <code>4</code> <code>ENLNAOUT</code> <code>0</code> Enable LNA outputs to ATM (bypass AFEBUF). <code>5</code> <code>ENLPFOUT</code> <code>0</code> Enable LPF outputs to ATM (bypass AFEBUF). <code>6</code> <code>ENMONAFE</code> <code>0</code> Enable AFE section monitoring. <code>7</code> <code>RESERVED</code> <code>0</code>"},{"location":"peripherals/configuration_registers/#0x1b-adc-control-1","title":"<code>0x1B</code> - ADC Control 1","text":"Bit Name Default Description <code>0</code> <code>ENADCANALOG</code> <code>0</code> Enable ADC analog section. <code>1</code> <code>ENMES</code> <code>0</code> Mismatch Error Shaping Enable. <code>2</code> <code>ENCHP</code> <code>0</code> Chopper Enable. <code>3</code> <code>ENDWA</code> <code>0</code> Dynamic Weighted Average Enable. <code>7:4</code> <code>ADCOSR&lt;3:0&gt;</code> <code>0000</code> ADC Over-Sampling Ratio."},{"location":"peripherals/configuration_registers/#0x23-global-control","title":"<code>0x23</code> - Global Control","text":"Bit Name Default Description <code>0</code> <code>PHASE2COUNT2[8]</code>? <code>0</code> LSB bits of Phase 2 Count (from CSV logic). <code>1</code> <code>PHASE2COUNT2[9]</code>? <code>0</code> MSB bits of Phase 2 Count. <code>5:2</code> <code>FIFOWATERMARK</code> <code>0</code> Data frames before <code>DATAREADY</code> triggers. <code>6</code> <code>FORCEWREN</code> <code>0</code> Enable register writes during sampling (not recommended). <code>7</code> <code>ENSAMP</code> <code>0</code> GLOBAL ENABLE - Starts sampling process. <p>[!NOTE] <code>PHASE2COUNT2</code> bits at address <code>0x23</code> represent the most significant bits of the Phase 2 count, extending the 8-bit value in <code>0x22</code>.</p>"},{"location":"peripherals/temp_sense/","title":"Temperature Sensor Control","text":"<p>The Temperature Sensor Control peripheral manages the operation of the on-chip temperature sensor. It operates in a one-shot mode, triggering a single measurement sequence for each assertion of the enable signal. The peripheral consists of two main blocks: <code>TempSense_Control</code> for timing/control logic and <code>Temperature_Buffer</code> for data storage.</p>"},{"location":"peripherals/temp_sense/#functional-description","title":"Functional Description","text":"<p>The <code>TempSense_Control</code> module is responsible for generating the <code>temp_run</code> signal, which enables the <code>SAMPLE_CLK</code> and the ADC/Sensor logic.</p>"},{"location":"peripherals/temp_sense/#one-shot-operation","title":"One-Shot Operation","text":"<ol> <li>Arming: The logic monitors the <code>ENMONTSENSE_sync</code> signal (synchronized to <code>HF_CLK</code>). A rising edge on <code>ENMONTSENSE_sync</code> arms the controller and asserts <code>temp_run</code> high.</li> <li>Running: While <code>temp_run</code> is high, the sensor performs its conversion.</li> <li>Completion: The controller waits for the <code>DONE</code> signal from the sensor. Upon receiving <code>DONE</code>, <code>temp_run</code> is immediately de-asserted (set to low).</li> <li>Re-Arming: The controller enters an idle state. To trigger a new measurement, <code>ENMONTSENSE_sync</code> must first be de-asserted (low) and then asserted (high) again.</li> </ol> <p>This \"one-shot\" behavior ensures that power is consumed only during the requested measurement interval, even if the enable signal remains high.</p>"},{"location":"peripherals/temp_sense/#buffer-logic","title":"Buffer Logic","text":"<p>The <code>Temperature_Buffer</code> module captures and holds the valid temperature result.</p> <ol> <li>Arming: Similar to the control logic, the buffer arms itself on the rising edge of <code>ENMONTSENSE_sync</code>.</li> <li>Capture: When the <code>DONE</code> signal is asserted, if the buffer is armed, it captures the 16-bit <code>RESULT</code> from the sensor into an internal register.</li> <li>Storage: The <code>TEMPVAL</code> output continuously drives this stored value until the next valid measurement completes.</li> <li>Safety: The buffer logic includes an interlock (flagged as <code>armed</code>) to ensure it only updates once per enable cycle, preventing spurious updates or data corruption if <code>DONE</code> were to glitch or re-assert unexpectedly without a new enable request.</li> </ol>"},{"location":"peripherals/temp_sense/#io-listing","title":"IO Listing","text":""},{"location":"peripherals/temp_sense/#tempsense_control","title":"TempSense_Control","text":"Signal Name Direction description <code>HF_CLK</code> Input High-frequency system clock. <code>NRST_sync</code> Input Active-low reset (synchronized). <code>ENMONTSENSE_sync</code> Input Control signal to enable temperature sensing (Level sensitive, rising edge triggers one-shot). <code>DONE</code> Input Signal from sensor indicating conversion is complete. <code>temp_run</code> Output Active-high enable for the sensor/ADC."},{"location":"peripherals/temp_sense/#temperature_buffer","title":"Temperature_Buffer","text":"Signal Name Direction Description <code>ENMONTSENSE_sync</code> Input Control signal used to arm the capture logic. <code>DONE</code> Input Strobe indicating valid data is ready to be captured. <code>NRST_sync</code> Input Active-low reset. <code>SAMPLE_CLK</code> Input Clock for the buffer registers (typically slower than HF_CLK). <code>RESULT</code> Input 16-bit temperature data from the sensor. <code>TEMPVAL</code> Output 16-bit register output holding the last valid temperature reading."},{"location":"system_overview/block_diagram/","title":"Pepper T4 System Overview - Block Diagram","text":"<p>This document provides a high-level overview of the <code>TLM</code> (Top Level Module) architecture, including a block diagram of the digital interactions and a description of the top-level interfaces.</p>"},{"location":"system_overview/block_diagram/#block-diagram","title":"Block Diagram","text":"<p>The following diagram illustrates the connectivity between the major submodules within the <code>TLM</code>.</p> <p></p>"},{"location":"system_overview/block_diagram/#interface-description","title":"Interface Description","text":"<p>The <code>TLM</code> module serves as the digital core, interfacing with the SPI master (external MCU/FPGA) and the analog frontend/ADC blocks.</p>"},{"location":"system_overview/block_diagram/#digital-io-control-spi","title":"Digital I/O (Control &amp; SPI)","text":"Port Name Direction Description <code>RESETN</code> Input Active-low asynchronous reset. <code>MOSI</code> Input Master Out Slave In (SPI Data). <code>MISO</code> Output Master In Slave Out (SPI Data). <code>SCK</code> Input SPI Clock. <code>CS</code> Input Chip Select (Active Low). <code>HF_CLK</code> Input High-Frequency System Clock (Main digital clock). <code>OEN</code> Output Output Enable (Active low when CS is low OR scanning). <code>DATA_RDY</code> Output Indicates new data is available in the FIFO. <code>INT</code> Output Interrupt signal (Active High), driven by Status Monitor."},{"location":"system_overview/block_diagram/#scan-chain","title":"Scan Chain","text":"Port Name Direction Description <code>SCANEN</code> Input Scan Enable. <code>SCANMODE</code> Input Scan Mode Select."},{"location":"system_overview/block_diagram/#analog-inputs-from-adcafe","title":"Analog Inputs (From ADC/AFE)","text":"Port Name Direction Description <code>RESULT [15:0]</code> Input Digital output data from the SAR ADC. <code>DONE</code> Input Pulse indicating ADC conversion completion. <code>ADCOVERFLOW</code> Input ADC overflow flag. <code>SATDETECT [7:0]</code> Input Saturation detection flags from AFE."},{"location":"system_overview/block_diagram/#analog-outputs-control-signals","title":"Analog Outputs (Control Signals)","text":"<p>These signals control the various analog blocks (AFE, ADC, Bias, etc.).</p>"},{"location":"system_overview/block_diagram/#cref-reference-control","title":"CREF (Reference Control)","text":"Port Name Width Description <code>ENREGAFE</code> 1 Enable AFE Regulator. <code>ENREGADC</code> 1 Enable ADC Regulator. <code>PDREGDIG</code> 1 Power Down Digital Regulator. <code>RTGB</code> 4 Resistor Tuning - Gap Band. <code>RTREGAFE</code> 4 Resistor Tuning - AFE Regulator. <code>RTREGADC</code> 4 Resistor Tuning - ADC Regulator. <code>RETREGDIG</code> 4 Resistor Tuning - Digital Regulator."},{"location":"system_overview/block_diagram/#afe-analog-front-end","title":"AFE (Analog Front End)","text":"Port Name Width Description <code>ENAFELNA</code> 1 Enable LNA (Low Noise Amplifier). <code>ENAFELPF</code> 1 Enable LPF (Low Pass Filter). <code>ENAFEBUF</code> 1 Enable AFE Buffer. <code>SENSEMODE</code> 1 Sensing Mode Select. <code>ENREFBUF</code> 1 Enable Reference Buffer. <code>REFMODE</code> 1 Reference Mode Select. <code>AFELPFBYP</code> 1 Bypass LPF. <code>AFERSTCH</code> 8 Reset Channel Switches. <code>AFEBUFRST</code> 1 Reset AFE Buffer. <code>AFEBUFGT</code> 2 AFE Buffer Guard Timing. <code>ENMONTSENSE</code> 1 Enable Temperature Sensor Monitor. <code>ENLNAOUT</code> 1 Enable LNA Output. <code>ENLPFOUT</code> 1 Enable LPF Output. <code>ENMONAFE</code> 1 Enable AFE Monitor. <code>AFELPFBW</code> 8 LPF Bandwidth Control. <code>CHSEL</code> 8 Channel Select (Global). <code>ENLOWPWR</code> 1 Enable Low Power Mode. <code>CHEN</code> 8 Channel Enable Mask."},{"location":"system_overview/block_diagram/#bias-bias-currents","title":"BIAS (Bias Currents)","text":"Port Name Width Description <code>ENBIAS</code> 1 Enable Bias Generation. <code>ENTSENSE</code> 1 Enable Temperature Sensor Bias. <code>ENITEST</code> 1 Enable Current Test. <code>RTBGBIAS</code> 4 Resistor Tuning - Bandgap Bias. <code>ITAFELNACHx</code> 4 LNA Bias Current (Channels 0-7). <code>ITAFELPFCHx</code> 4 LPF Bias Current (Channels 0-7). <code>ITAFEBUF</code> 4 AFE Buffer Bias Current. <code>ITADC</code> 4 ADC Bias Current."},{"location":"system_overview/block_diagram/#adc-analog-to-digital-converter","title":"ADC (Analog to Digital Converter)","text":"Port Name Width Description <code>ENADCANALOG</code> 1 Enable Analog ADC parts. <code>ENMES</code> 1 Enable Measure. <code>ENCHP</code> 1 Enable Chopping. <code>ENDWA</code> 1 Enable Data Weighted Averaging. <code>ADCOSR</code> 4 ADC Oversampling Ratio. <code>ADCGAIN</code> 4 ADC Gain Setting. <code>ENEXTCLK</code> 1 Enable External Clock. <code>DONEOVERRIDE</code> 1 Override DONE signal. <code>DONEOVERRIDEVAL</code> 1 Value for DONE Override. <code>ANARSTOVERRIDE</code> 1 Override Analog Reset. <code>ANARSTOVERRIDEVAL</code> 1 Value for Analog Reset Override. <code>DIGDEBUGSEL</code> 3 Digital Debug Select. <code>ANATESTSEL</code> 3 Analog Test Select. <code>SAMPLE_CLK</code> 1 Generated Sampling Clock for ADC. <code>nARST</code> 1 Analog Reset (Active Low) - Controls ADC timing."},{"location":"system_overview/block_diagram/#atm-analog-test-mode","title":"ATM (Analog Test Mode)","text":"Port Name Width Description <code>ENATMIN</code> 1 Enable ATM Input. <code>ENATMOUT</code> 1 Enable ATM Output. <code>ENATMLNA</code> 1 Enable ATM LNA. <code>ENATMLPF</code> 1 Enable ATM LPF. <code>ENATMBUF</code> 1 Enable ATM Buffer. <code>ENTESTADC</code> 1 Enable Test ADC. <code>ATMBUFBYP</code> 1 Bypass ATM Buffer. <code>ATMMODE</code> 3 ATM Mode Select. <code>ATMCHSEL</code> 8 ATM Channel Select (Muxed)."},{"location":"system_overview/block_diagram/#raw-register-outputs","title":"Raw Register Outputs","text":"<p>Ports <code>REG_00</code> through <code>REG_23</code> expose the raw configuration register bits for debug or direct control purposes.</p>"}]}